# Java&Linux复习

今天把Linux和Java这些日子的知识点回忆一下，以写代码为主吧，嗯。

## Linux

1. 1970年可以看作 Unix 诞生元年
2. Linux的意思是 Linux is not Unix 的意思
3. Linux的系统组成可以看成一个洋葱模型：内核→外壳→文件系统
4. Linux内核的作用就是管理硬件设备、内存、进程等
5. 外壳也就是shell，是个解释器，接受用户命令，交给内核去执行
6. $这个标志的出现代表普通用户
7. #这个标志的出现代表超级用户root
8. 使用su命令切换用户，什么都不填默认切换到超级用户
9. su后面如果跟一个-的话，就是切换到超级用户并且使用超级用户的用户配置
10. 超级用户切换普通用户也可以使用exit
11. 可以使用whoami查看当前用户是谁
12. 文件系统的功能是管理所用文件，是个倒立的树形结构
13. Linux中/是根目录
14. .表示当前目录，..表示上一级目录
15. 绝对路径就是以/开头的，否则是相对路径
16. ~这个表示家目录，一般是/home/zyj这样
17. 我们可以使用df -h查看分区
18. 常用目录了解一下？
    1. /bin bin是Binary的缩写，这个目录存放着最经常使用的命令。
    2. /boot 这个目录下存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。
    3. /dev 这个目录是Device设备的意思，存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。
    4. /home 用户的主目录，在Linux中，每个用户都有自己的一个目录，一般该目录是以用户的账号命名的。
    5. /lib 这个目录里存放的是系统最基本的动态链接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些动态链接共享库。
    6. /lost+found 这个目录一般是空的，当系统非法关机以后，这里就存放了一些文件
    7. /media Linux系统会自动识别一些设备，例如U盘、光驱等，当时别以后，Linux会把识别的设备挂载在这个目录下面
    8. /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以把光驱挂载在/mnt/上，然后进去这个目录就能看到光驱里的内容了。
    9. /opt 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库就可以放在这个文件夹下，默认是空的/
    10. /proc 这个目录是一个虚拟目录，他是系统内存的映射，我们可以通过这个目录来获取系统信息，这个目录的内容不是在硬盘上，而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，是别人无法ping你的机器`echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all`
    11. /root 该目录为系统管理员，也称作超级权限者的用户主目录
    12. /sbin s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。
    13. /selinux 这个目录是RedHeat/CentOS的特有的目录，Selinux是一个安全机制，类似于Windows防火墙这样的，但是这套机制比较复杂，这个目录就是存放selinux相关文件的。
    14. /srv 该目录存放一些服务启动后所需要提取的数据。
    15. /sys 这是Linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。
    16. /tmp 这个目录是用来存放一些临时文件的
    17. /usr 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program目录
    18. /usr/bin 系统用户使用的用用程序
    19. /usr/sbin 超级用户使用的比较高级的管理程序和系统守护程序
    20. /usr/src 内核源代码的默认放置目录。
    21. /var 这个目录中存放着在不断扩充的东西，我们习惯将那些经常被修改的目录放在这个目录下，包括各种日志文件。
    22. /run 实力个临时文件系统，存储系统启动以来的信息，当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让他指向run
19. 常用命令了解一下？
    1. 首先先看命令的语法：命令+选项+参数，用空格作为分隔符，一般不超过256字符、大小写敏感。
    2. 下面的命令按照字母顺序给出，需要详细了解的会写的全一点，否则就写个功能。
    3. cat
        1. cat命令用于连接文件并打印到标准输出设备上。
        2. 使用权限：所有使用者
        3. `cat [-AbeEnstTuv] [--help] [--version] fileName`
        4. -n 或 --number：由 1 开始对所有输出的行数编号。
        5. -b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。
        6. -s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。
        7. -v 或 --show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。
        8. -E 或 --show-ends : 在每行结束处显示 $。
        9. -T 或 --show-tabs: 将 TAB 字符显示为 ^I。
        10. -A, --show-all：等价于 -vET。
        11. -e：等价于"-vE"选项
        12. -t：等价于"-vT"选项；
    4. chmod
        1. Linux/Unix文件调用权限分为三级：文件拥有者、群组、其他。利用chmod可以藉以控制文件如何被他人调用。
        2. 使用权限：所有使用者
        3. `chmod [-cfvR] [--help] [--version] mode file...`
        4. u表示该文件的拥有者，g表示与该文件拥有者属于同一个群组的者，o表示其他以外的人，a表示这三者皆是
        5. +表示增加权限，-表示取消权限，=表示唯一设定权限
        6. r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行
        7. -c : 若该文件权限确实已经更改，才显示其更改动作
        8. -f : 若该文件权限无法被更改也不要显示错误讯息
        9. -v : 显示权限变更的详细资料
        10. -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)
        11. --help : 显示辅助说明
        12. --version : 显示版本
        13. chmod也可以使用数字来表示权限，`chmod abc file`。abc表示u、g、o的权限数字，rwx数字分别为4、2、1，取什么权限相加即可。例如rwx就是4+2+1=7，rw就是4+2=6之类。
        14. 若用`chmod 4755 filename`可以使该程序具有root的权限
    5. chown
        1. 利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。
        2. 使用权限：root
        3. `chown [-cfhvR] [--help] [--version] user[:group] file...`
    6. diff
        1. Linux diff命令用于比较文件的差异。diff以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。
        2. `diff [-abBcdefHilnNpPqrstTuvwy][-<行数>][-C <行数>][-D <巨集名称>][-I <字符或字符串>][-S <文件>][-W <宽度>][-x <文件或目录>][-X <文件>][--help][--left-column][--suppress-common-line][文件或目录1][文件或目录2]`
    7. file
        1. Linux file命令用于辨识文件类型。通过file指令，我们得以辨识该文件的类型。
        2. `file [-bcLvz][-f <名称文件>][-m <魔法数字文件>...][文件或目录...]`
        3. -b 　列出辨识结果时，不显示文件名称。
        4. -c 　详细显示指令执行过程，便于排错或分析程序执行的情形。
        5. -f<名称文件> 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。
        6. -L 　直接显示符号连接所指向的文件的类别。
        7. -m<魔法数字文件> 　指定魔法数字文件。
        8. -v 　显示版本信息。
        9. -z 　尝试去解读压缩文件的内容。
        10. [文件或目录...] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。
    8. find
        1. Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。
    9. mv
        1. Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。
        2. `mv [options] source dest`
        3. `mv [options] source... directory`
        4. -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;
        5. -f: 在mv操作要覆盖某已有的目标文件时不给任何指示;
    10. clear
        1. Linux clear命令用于清除屏幕。
    11. pwd
        1. Linux pwd命令用于显示工作目录。执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。
        2. `pwd [--help][--version]`
    12. cd
        1. Linux cd命令用于切换当前工作目录至 dirName(目录参数)。其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。另外，"~" 也表示为 home 目录 的意思，"." 则是表示目前所在的目录，".." 则表示目前目录位置的上一层目录。
        2. `cd [dirName]`
    13. ls
        1. Linux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。
        2. `ls [-alrtAFR] [name...]`
        3. -a 显示所有文件及目录 (ls内定将文件名或目录名称开头为"."的视为隐藏档，不会列出)
        4. -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出
        5. -r 将文件以相反次序显示(原定依英文字母次序)
        6. -t 将文件依建立时间之先后次序列出
        7. -A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)
        8. -F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"
        9. -R 若目录下有文件，则以下之文件亦皆依序列出
    14. touch
        1. Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。ls -l 可以显示档案的时间记录。
        2. `touch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]`
        3. a 改变档案的读取时间记录。
        4. m 改变档案的修改时间记录。
        5. c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。
        6. f 不使用，是为了与其他 unix 系统的相容性而保留。
        7. r 使用参考档的时间记录，与 --file 的效果一样。
        8. d 设定时间与日期，可以使用各种不同的格式。
        9. t 设定档案的时间记录，格式与 date 指令相同。
        10. --no-create 不会建立新档案。
        11. --help 列出指令格式。
        12. --version 列出版本讯息。
    15. mkdir
        1. Linux mkdir命令用于建立名称为 dirName 之子目录。
        2. `mkdir [-p] dirName`
        3. -p 确保目录名称存在，不存在的就建一个。
    16. cp
        1. Linux cp命令主要用于复制文件或目录。
        2. `cp [options] source dest`
        3. `cp [options] source... directory`
        4. -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。
        5. -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。
        6. -f：覆盖已经存在的目标文件而不给出提示。
        7. -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。
        8. -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。
        9. -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。
        10. -l：不复制文件，只是生成链接文件。
    17. rm
        1. Linux rm命令用于删除一个文件或者目录。
        2. `rm [options] name...`
        3. -i 删除前逐一询问确认。
        4. -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。
        5. -r 将目录及以下之档案亦逐一删除。
        6. 删除文件可以直接使用rm命令，若删除目录则必须配合选项"-r"
    18. man
    19. info
    20. telnet
        1. Linux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。
    21. exit
        1. Linux exit命令用于退出目前的shell。执行exit可使shell以指定的状态值退出。若不设置状态值参数，则shell以预设值退出。状态值0代表执行成功，其他值代表执行失败。exit也可用在script，离开正在执行的script，回到shell。
    22. ping
        1. Linux ping命令用于检测主机。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。
    23. ifconfig
        1. Linux ifconfig命令用于显示或设置网络设备.ifconfig可设置网络设备的状态，或是显示目前的设置。
    24. more
        1. Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。
    25. head
    26. tail
        1. tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。tail -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。
    27. history
    28. !
    29. !!
    30. alias
        1. Linux alias命令用于设置指令的别名。用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.cshrc中设定指令的别名。
    31. grep
        1. Linux grep 命令用于查找文件里符合条件的字符串。grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。
    32. ln
        1. Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。
        2. `ln [参数][源文件或目录][目标文件或目录]`
        3. Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。
        4. 软链接：
            1. 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
            2. 软链接可以 跨文件系统 ，硬链接不可以
            3. 软链接可以对一个不存在的文件名进行链接
            4. 软链接可以对目录进行链接
        5. 硬链接：
           1. 硬链接，以文件副本的形式存在。但不占用实际空间。
           2. 不允许给目录创建硬链接
           3. 硬链接只有在同一个文件系统中才能创建
    33. crontab
        1. Linux crontab是用来定期执行程序的命令。当安装完成操作系统之后，默认便会启动此任务调度命令。crond命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。而linux任务调度的工作主要分为以下两类：  
            1. 系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存
            2. 个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置
        2. `crontab [ -u user ] file`
        3. `crontab [ -u user ] { -l | -r | -e }`
        4. 时程表的格式如下：`f1 f2 f3 f4 f5 program`
            1. 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。
            2. 当 f1 为 \* 时表示每分钟都要执行 program，f2 为 \* 时表示每小时都要执行程序，其馀类推
            3. 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推
            4. 当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推
            5. 当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其馀类推
20. Linux元字符
    1. \* 代表0或多个字符
    2. ？ 代表单一字符
    3. \[\]给定字符列表中匹配一个字符
    4. ； 连接多个命令，顺序执行
    5. | 管道符，将前面命令的输出结果座位后面命令的输入内容
    6. \> 重定向输出方向，从屏幕变为文件，覆盖方式
    7. \>\> 重定向输出方向，从屏幕变为文件，追加方式
    8. \< 重定向输入方向，从键盘变为文件。
21. vi编辑器
    1. vi编辑器有三种模式：命令模式（command mode）、插入模式（Insert mode）、底行模式（last line mode）。
    2. k：上
    3. j：下
    4. h：左
    5. l：右
    6. i：光标所在位置插入
    7. a：光标所在位置后插入
    8. o：光标所在行的下一行插入
    9. O：光标所在行的上一行插入
    10. Esc：输入模式回到命令模式
    11. x：删除一个字符
    12. dd：删除一行
    13. r：替换一个字符
    14. cc：替换一行
    15. yy：拷贝一行
    16. p：粘贴
    17. :w：保存
    18. :w filename：另存为
    19. :wq：保存并退出vi
    20. :q!：退出vi不保存
    21. ~：大小写转换
    22. J：Join，上下两行合成一行
    23. u：undo，撤销刚刚执行过的操作
    24. :set nu：设置行号
    25. :set nonu：取消行号设置
    26. :21：定位到21行
    27. 21G：定位到21行
    28. G：定位到最尾行
    29. 0：定位到当前行头
    30. $：定位到当前行尾
    31. /：光标所在位置往下查找
    32. ?：光标所在位置往上查找
    33. n：查找下一处
    34. :r filepath：在光标所在位置的下一行，插入另外一个文件的内容
    35. :1,$s/旧串/新串/g：全文替换
    36. :%s/旧串/新串/g：全文替换
22. 初始化文件
    1. 环境变量：一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时目录位置、系统目录位置、第三方应用软件的位置等
    2. 自定义环境变量： 环境变量名=环境变量值
    3. 获取环境变量值： $环境变量名
    4. umask：权限掩码，影响新建目录、文件的默认权限
    5. 新建目录的默认权限：777-umask值
    6. 新建文件的默认权限：777-umask值后，去掉执行权限
23. 扩展
    1. 设置UID，s权限加在拥有者上，针对可执行程序，在程序执行过程中，临时将程序调用者的权限提升为文件拥有者的权限
    2. 设置GID，s权限加在同组人上，针对可执行程序，在程序执行过程中，临时将程序调用者的权限提升为文件所属组的权限
    3. 粘着位，t权限，只针对目录，对目录中的内容删除有限制。root、目录拥有者不受限；其他用户只能删除自己的文件，不能删除别人的文件。例如：服务器上提交作业的共享目录。

## Java

1. Java历史无需多言，了解即可
2. 什么是JDK
    1. JDK，即Java Development Kit。JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包含了JRE，所以我们安装了JDK，就不需要再安装JRE了。
    2. 这里说的java开发工具是指
        - 编译工具->javac
        - 打包工具->jar
        - 等等。。
    3. 所以**JDK=JRE+JAVA开发工具**
3. 什么是JRE
    - 那JRE的话，就是Java Runtime Environment，包括JVM（Java虚拟机）和Java需要的核心类库。如果想运行一个开发好的Java程序，就需要安装JRE。
    - 所以说**JRE=JVM+类库**
4. Java安装相关
    - 了解之后我们开始安装JDK，安装好之后还需要配置环境变量。还记得我们在Linux那个文件里配置的吗？用户家目录下的.bashrc文件。
    - 配置的主要是如下的东西：
        - JAVA_HOME->JDK安装路径
        - PATH->添加Java工具命令的路径
        - CLASSPATH->Java类的装载路径
5. JDK目录结构
    - ![image.png](https://i.loli.net/2019/10/09/kZqJcr36mlM8GOz.png)
    - bin: 开发工具
    - include: 头文件
    - db: 自带的小型数据库
    - lib: 类库
    - jre: java运行环境
    - src.zip: java源代码
6. 什么是Java
    - 它是一种开发语言，也是一种编程环境、应用环境、部署环境。
7. Java语言的特点
    - Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点，下面针对这些特点进行逐一介绍。
        1. 面向对象  
        Java 是一种面向对象的语言，它对对象中的类、对象、继承、封装、多态、接口、包等均有很好的支持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。使用 Java 语言开发程序，需要采用面向对象的思想设计程序和编写代码。  
        2. 平台无关性  
        平台无关性的具体表现在于，Java 是“一次编写，到处运行（Write Once，Run any Where）”的语言，因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。  
        Java 语言使用 Java 虚拟机机制屏蔽了具体平台的相关信息，使得 Java 语言编译的程序只需生成虚拟机上的目标代码，就可以在多种平台上不加修改地运行。  
        3. 简单性  
        Java 语言的语法与 C 语言和 C++ 语言很相近，使得很多程序员学起来很容易。对 Java 来说，它舍弃了很多 C++ 中难以理解的特性，如操作符的重载和多继承等，而且 Java 语言不使用指针，加入了垃圾回收机制，解决了程序员需要管理内存的问题，使编程变得更加简单。
        4. 解释执行  
        Java 程序在 Java 平台运行时会被编译成字节码文件，然后可以在有 Java 环境的操作系统上运行。在运行文件时，Java 的解释器对这些字节码进行解释执行，执行过程中需要加入的类在连接阶段被载入到运行环境中。  
        5. 多线程  
        Java 语言是多线程的，这也是 Java 语言的一大特性，它必须由 Thread 类和它的子类来创建。Java 支持多个线程同时执行，并提供多线程之间的同步机制。任何一个线程都有自己的 run() 方法，要执行的方法就写在 run() 方法体内。  
        6. 分布式  
        Java 语言支持 Internet 应用的开发，在 Java 的基本应用编程接口中就有一个网络应用编程接口，它提供了网络应用编程的类库，包括 URL、URLConnection、Socket 等。Java 的 RIM 机制也是开发分布式应用的重要手段。
        7. 健壮性  
        Java 的强类型机制、异常处理、垃圾回收机制等都是 Java 健壮性的重要保证。对指针的丢弃是 Java 的一大进步。另外，Java 的异常机制也是健壮性的一大体现。  
        8. 高性能  
        Java 的高性能主要是相对其他高级脚本语言来说的，随着 JIT（Just in Time）的发展，Java 的运行速度也越来越高。
        9. 安全性  
        Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防止恶意代码的攻击。除了 Java 语言具有许多的安全特性以外，Java 还对通过网络下载的类增加一个安全防范机制，分配不同的名字空间以防替代本地的同名类，并包含安全管理机制。  
        Java 语言的众多特性使其在众多的编程语言中占有较大的市场份额，Java 语言对对象的支持和强大的 API 使得编程工作变得更加容易和快捷，大大降低了程序的开发成本。Java 的“一次编写，到处执行”正是它吸引众多商家和编程人员的一大优势。
    - 简单版
        - 开源
        - 简单易用
          - 无指针，程序员不需要管理内存
        - 跨平台（JVM）
        - 支持多线程（提高并发效率）
        - 动态更新
        - 面向对象编程
        - 安全（代码安全校验器）
8. JVM
    - JVM我们看Java开发手册，这里我就不写了，太多了
9. GC
    - GC也是看Java开发手册，太多不写
10. Java代码安全
    - 代码安全主要就讲了个字节码校验器？看看之前总结的，我现在不想总结这个了。
    - 代码符合JVM规范
    - 不能破坏系统完整性
    - 不能有栈溢出
    - 参数类型要正确
    - 类型转换要正确
    - JIT:Just In Time，即时编译器，提高java代码的运行效率
11. 编程步骤
    - 编辑➡编译➡运行

    ```BASH
    vi src/Hello.java
    javac -d classes src/Hello.java
    java -cp classes cn.royians.review.Hello
    ```

12. 包
    - 解决命名冲突问题，分类管理。
13. jar命令
    - 打包：jar -cvf my.jar cn  
    - jar -xvf my.jar  
    - jar -tvf my.jar  
    - -cvf: 将.class文件打包
    - -xvf: 将.jar文件解包
    - -tvf: 查看.jar文件内容
    - `java -cp my.jar cn.royians.review.Hello`
14. API
    - 类的使用帮助文档
    - 包→类→属性、方法
15. Java注释有哪些？
    - 注释分三种
        - 单行注释
        - 多行注释
        - 文档注释
    - 单行注释主要用来对变量做简单描述  
    - 多行注释一般用来描述类、方法、算法  
    - 文档注释主要可以用来产生API文档。
    - 单行注释是可以嵌套的，但剩下那俩不行。  
    - 注释可以用来增加文章的可读性，只是在源文件中有效，编译成字节码以后，就全没了。  
    - 注释可以用来代码调试。
16. Java代码规范
    - 这个我在Java开发手册规范里看吧，这里不怎么说了
17. Java命名规则
    - 开头的必须是字母、下划线或者dollar符；而且命名是大小写敏感的，而且无长度限制（这一点的话呢，虽然说语言没有限制，但是这个长度是被机器限制了），而且肯定也不能用保留字/关键字。
18. Java中的标识符
    - ![Java中的关键字](https://i.loli.net/2019/10/09/E9drbgt4YqFHuCR.png)
19. Java数据类型
    1. 基本数据类型
        1. boolean，取值只能是true或false
        2. char，字符型，存放的是字符常量，底层用16位无符号整型数表示。这里需要我们记一下ASCII码，记常用的就行。比如0的编码是48，然后0123456789这样顺序排下去，最后那个9的编码是57.之后是：、；、<、=、>、？、@这种字符，然后从编号为65的A开始按字母顺序排列，一直到90的Z，然后又是一堆标点符号，到97的a记到122的z就行了。
        3. 整型族 位
            1. byte 8
            2. short 16
            3. int 32
            4. long 64
            5. 整型常量字面值默认是INT类型，可以直接赋给整型族变量（只要在范围内）
        4. 浮点型族
            1. float
            2. double
            3. 浮点常量字面值默认是double类型
            4. 建议使用BigDecimal或者Long（单位为分）来表示金额。
    2. 类类型（引用类型）
        1. String
            - [总结](https://www.jianshu.com/p/0dc5d48a1794)
            - [字符串的不可变性](https://www.cnblogs.com/qingergege/p/5701011.html)
            - [JDK 6和JDK 7中substring的原理及区别](https://www.cnblogs.com/dsitn/p/7151624.html)
            - [String对“+”的重载](https://www.jianshu.com/p/9bf533e40d30)
            - 字符串拼接的几种方式和区别
                - "+":有人把Java中使用`+`拼接字符串的功能理解为**运算符重载**。其实并不是，**Java是不支持运算符重载的**。这其实只是Java提供的一个**语法糖**
                - concat

                ```java
                String wechat = "ROYIANS";
                String introduce = "你好呀";
                String ROYIANS = wechat.concat(",").concat(introduce);
                ```

                - StringBuffer

                ```java
                StringBuffer wechat = new StringBuffer("ROYIANS");
                String introduce = "你好呀";
                StringBuffer ROYIANS = wechat.append(",").append(introduce);
                ```

                - StringBuilder

                ```java
                StringBuilder wechat = new StringBuilder("ROYIANS");
                String introduce = "你好呀";
                StringBuilder ROYIANS = wechat.append(",").append(introduce);
                ```

                - StringUtils.join

                ```java
                String wechat = "ROYIANS";
                String introduce = "你好呀";
                System.out.println(StringUtils.join(wechat, ",", introduce));
                String[] strs = {"str1", "str2"};
                System.out.println(StringUtils.join(Arrays.asList(strs),","));
                ```

            - [String.valueOf和Integer.toString的区别](https://github.com/ROYIANSchuang/toBeTopJavaer/blob/master/basics/java-basic/value-of-vs-to-string.md)
            - [switch对String的支持](https://github.com/ROYIANSchuang/toBeTopJavaer/blob/master/basics/java-basic/switch-string.md)
            - 字符串池
            - 常量池
                - 运行时常量池
                - Class常量池
            - intern
20. 什么是常量
    - 在程序执行过程中其值不可以发生改变
    - 常量是指在程序的整个运行过程中值保持不变的量。
    - 在这里要注意常量和常量值是不同的概念，常量值是常量的具体和直观的表现形式，常量是形式化的表现。
    - 通常在程序中既可以直接使用常量值，也可以使用常量。
21. Java中常量的分类
    1. 字面值常量
        1. 字符串常量 用双引号引起来的内容
        2. 整数常量 所有整数
        3. 小数常量 所有小数
        4. 字符常量 用单引号引起来的内容，里面只能放单个数字，单个字母或者单个符号
        5. 布尔常量 只有true和false
        6. 空常量 null
    2. 自定义常量
22. 什么是变量
    1. 在程序执行的过程中，在某个范围内其值可以改变的量
    2. 变量的定义的格式：数据类型 变量名 = 变量值
    3. 为什么要定义变量：用来存放同一类型的常量，并可以重复使用
23. 什么是类
    - 现实世界中，具有相同属性、相同行为的事物的抽象
24. 什么是对象
    - 类的具体化、实例化
25. 什么是面向对象
    - 将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。
    - 就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。
26. 面向对象编程的过程
    - 抽象类（class）→创建对象（new）→.访问属性（成员变量）、行为（成员方法）
27. 什么是局部变量
    - 定义在方法的里面
    - 必须先赋值后使用
    - 作用域是声明那一行到方法的右半花括号
28. 什么是实例变量
    - 定义在类的里面，方法的外面
    - 可以不用初始化直接使用，有默认值
    - 作用域：类的内部
29. 什么是作用域
    - 指标识符可以使用的有效范围
30. 什么是可见性
    - 指标识符可以被访问、引用的范围
    - 作用域内不一定可见，但可见一定在作用域内。
31. 任意进制到十进制的转换
32. 原码补码反码
    1. 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。
    2. 正数的补码与其原码相同；负数的补码是在其反码的末位加1。
33. 赋值操作符
    - int a = 10;
    - 数据类型要匹配
    - 左边只能是变量
    - 复合赋值运算符会将右值的类型隐式转换为左边的类型，可能会造成数据损失
34. [instanceof](https://www.cnblogs.com/ysocean/p/8486500.html)
    - 判断对象是否是某一类类型
    - 不能操作基本数据类型
    - java.lang.Object是所有类的父类
35. ==
    1. 如果是基本数据类型，==判断的是值
    2. 如果是对象类型，==判断的是对象的地址
36. 移位运算
    1. 左移运算符用“<<”表示，是将运算符左边的对象，向左移动运算符右边指定的位数，并且在低位补零；其实向左移n 位，就相当于乘上2的n次方。
    2. 右移运算符用符号“>>>”表示，逻辑右移，是将运算符左边的对象向右移动运算符右边指定的位数，并且在高位补0；其实右移n位，就相当于除上2的n次方。
    3. 带符号的右移运算符用符号“>>”表示，算数右移，是将运算符左边的运算对象，向右移动运算符右边指定的位数。如果是正数，在高位补零，如果是负数，则在高位补1
37. 位运算符
    1. & 与0相&，将某位清零
    2. | 与1相|，将某位置一
    3. ^ 与1相^，将某位反转
38. 逻辑运算符
    1. && 逻辑运算符，具有逻辑短路功能（连接的两个条件，如果第一个条件为假，后面的条件不进行运算）
    2. & 位运算符，但可以连接多个条件，但没有短路功能
39. [& 和 && 的区别](https://www.jianshu.com/p/7fe355536cc4)
40. 三目运算符 ？ ：
41. ++、--
    - ![img](https://i.bmp.ovh/imgs/2019/10/d396932c52a8faec.png)
42. Java类型转换
    1. 隐式类型转换，即自动类型转换，由系统自动完成的类型转换。从存储范围小的类型到存储范围大的类型。byte→short(char)→int→long→float→double。不仅如此，当把任何基本类型的值和字符串值进行连接运算时，基本类型的值将自动类型转换成字符串类型，虽然字符串类型不是基本类型，而是引用类型，因此，如果希望把基本类型的值转换为对应的字符串时，可以把基本类型的值和一个空字符串进行连接。
    2. 显式类型转换，即强制类型转换，就是缩小转换。
43. 顺序结构
44. 条件语句
    1. if
    2. if...else...
    3. if...else if...else...
45. 分支语句 switch
    - 表达式的数据类型，可以是byte、short、int、char、enum、String
46. 循环语句
    1. for
    2. while
    3. do...while...
    4. for、while区别
47. break、continue
    - break[label]：终止switch或者循环
    - continue[label]：结束本次循环，继续下一次的循环
    - Java中的标签是为循环设计的，是为了在多重循环中方便地使用break和continue跳到标签处
48. 死循环
    1. for(;;){...}
    2. while(true){...}
    3. do{...}while(true)
49. 什么是数组
    - Java中的数组是对象，有长度和数组成员
50. 如何声明数组
    - 数据类型[] 数组名
    - 数据类型 数组名[]
51. 如何创建数组
    - 数据类型[] 数组名 = new 数据类型[长度]
    - 数据类型[] 数组名 = new 数据类型[]{元素1, 元素2, ...}
    - 数据类型[] 数组名 = {元素1, 元素2, ...}
    - 可以存放基本数据类型，也可以存放类类型
    - 数组分配好堆内存后，会对成员进行默认初始化（数值类型为0，boolean类型为false，引用类型为null
52. 如何访问数组
    - 数组名[索引]
    - 数组名[索引] = 数值 为数组中的元素赋值
    - 变量 = 数组名[索引] 获取数组中的元素
    - 数组动态初始化： new分配内存，[]访问数组成员赋值，声明、赋值可以分开写
    - 数组的静态初始化：{}直接分配内存、赋值，声明、赋值不能分开写
53. 数组长度
    - 数组有长度，是固定的，Java赋予数组一个属性，可以获取到数组的长度，即 数组名.length
    - 数组下标访问时，可以使用变量
    - 数组访问时，编译器不会检查下标范围，需要自己负责
54. 数组遍历
    - fori
    - foreach
55. 数组常见异常
    1. ArrayIndexOutOfBoundsException
        - 数组下标越界
    2. NullPointerException
        - 空指针异常
56. 数组作为参数
    - 传递的参数是数组内存地址
57. 数组作为返回值
    - 返回的是数组的内存地址
58. 如何拷贝一个数组
    - System.arraycopy(...)

    ```java
    package cn.royians.review;

    import java.util.Arrays;

    public class ShuZuTest {
        public static void main(String[] args) {
            int[] intarr1 = {1,2,3,4,5,6};
            int[] intarr2 = new int[intarr1.length];
            System.arraycopy(intarr1,0,intarr2,0,intarr1.length);
            System.out.println(Arrays.toString(intarr1));
            System.out.println(Arrays.toString(intarr2));
        }
    }
    ```

59. 多维数组的练习
    - 其实没有多维数组，所谓的二维数组，就是一个一维数组，然后里面的元素是一维数组。
60. 什么叫可变参数
    - 底层用数组实现，一个参数列表中只能出现一个可变参数，并在所有参数的最后声明
    - someMethod(String... strings){...}
61. 面向对象编程思想
    - 强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现
    - 面向过程强调的是步骤，面向对象强调的是对象
    - 面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从中兴这变成了指挥者
    - 面向对象的三大特性：封装、继承、多态
62. 面向对象编程步骤
    1. 定义类

        ```java
        public class 类名 {
            //成员变量
            //成员方法
        }
        ```

    2. 创建对象

        ```java
        类名 对象名 = new 类名();
        ```

    3. 访问成员

        ```java
        对象名.成员变量;
        对象名.成员方法();
        ```

63. 什么是方法
    - 完成特定功能的代码块
64. 为甚要有方法
    - 提高代码复用性
65. 方法的格式

    ```java
    修饰符 返回值类型 方法名(参数类型 参数名1, 参数类型 参数名2...) {
        方法体语句;
        return 返回值;
    }
    ```

66. 方法格式的说明
    - 修饰符 public static protected private final
    - 返回值类型 就是功能结果的数据类型
    - 方法名 符合命名规则即可，方便我们的调用
    - 参数：
        - 实际参数：就是方法调用时的，实际参与运算的
        - 形式参数：就是方法定义上的，用于接收实际参数的
    - 参数类型：就是参数的数据类型
    - 参数名：就是变量名
    - 方法体语句：就是完成功能的代码
    - return：结束方法的，可以携带返回值也可以不携带
    - 返回值：就是功能的结果，由return带给调用者
67. 方法的注意事项
    - 方法不调用不执行
    - 方法与方法是平级关系，不能嵌套定义
    - 方法定义的时候参数之间用逗号隔开
    - 方法调用的时候不用再传递数据类型
    - 如果方法有明确的返回值，一定要有一个return带回一个值。
68. 什么叫封装
    - 封装是指隐藏对象的属性和实现细节，仅对外提供公共访问方式
69. 什么叫递归
    - 方法自己调用自己
    - 好处是不知道循环次数的时候可以用
    - 弊端是不能调用的次数太多，可能导致栈溢出
70. 封装有什么好处
    - 隐藏对象的属性和实现细节，仅对外提供公共访问方式
    - 提高了代码的复用性
    - 提高了安全性
71. 封装有哪些原则
    - 把属性隐藏，提供公共方法对其访问
    - 将不需要对外提供的内容都隐藏起来
72. private关键字 封装的操作
    - private关键字的特点：
        - 是一个权限修饰符
        - 可以修饰成员变量和成员方法
        - 被其修饰的成员只能在本类中被访问
        - private仅仅是封装一种体现形式，不能说封装就是私有
73. this
    - 代表所在类的当前对象的引用（地址值）
    - this.成员变量名
    - this.成员方法名
74. 方法重载
    - 在同一类中
    - 相同的方法名
    - 参数列表有所不同（参数类型、参数数量、参数顺序）
    - 不关心返回值类型
75. 什么叫初始化对象
76. 如何创建初始化对象
    - 在栈中分配空间，存放引用变量
    - 在堆中分配空间，存储对象；对象属性进行默认初始化
    - 引用变量指向堆地址
    - 使用成员变量值进行属性赋值
    - 调用构造器方法
77. 什么是构造器方法
    - 是一种特殊的方法，构建类对象时被调用
    - 和类同名
    - 没有返回值类型
    - 可以通过this(...)调用本类其他构造器，必须是构造器第一条语句
    - 如果没有提供构造器，系统会提供一个默认构造器（无参、空体）；如果提供了构造器，系统将不会提供默认构造器；建议自己在类中都添加一个无参构造器。
78. 什么是继承 extend
    - 多个类中存在相同的行为和属性时候。
    - 将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。
    - 其中，多个类可以称为子类
    - 单独的那一个类称为父类、超类或者基类
79. 继承有什么好处
    - 提高了代码的复用性
    - 提高了代码的维护性
    - 让类与类之间产生了关系，是多态的前提
80. 继承有什么弊端
    - 类的耦合性增强了
    - 开发的原则：高内聚、低耦合
    - 耦合：类和类的关系
    - 内聚：就是自己完成某件事情的能力
81. 什么时候用继承
    - 继承体现的是一种关系：“is-a”
82. 继承的特点
    - Java只支持单继承，不支持多继承
    - Java支持多层继承
83. [继承中成员变量与成员方法的关系](https://www.cnblogs.com/fuck1/p/5437777.html)
    - 继承中成员变量的关系
        - 子类的成员变量名称和父类中的成员变量名称不一样，这个太简单写那个名字就访问那个名字！
        - 子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?
            - 子类的方法访问变量的查找顺序：
                - 在子类方法的局部范围找，有就使用。
                - 在子类的成员范围找，有就使用。
                - 在父类的成员范围找，有就使用。
                - 找不到，就报错。
    - 继承中构造方法的关系
        - 子类的构造方法默认会去访问父类的无参构造方法，因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。
        - 子类通过super去明确调用带参构造，通过明确的调用指定的父类带参构造，为父类数据进行初始化。
        - 子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造，this();
    - 继承中成员方法的关系
        - 子类的成员方法和父类中的成员方法名称不一样，这个太简单
        - 子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?
            - 通过子类对象访问一个方法的查找顺序：
                - 在子类中找，有就使用
                - 在父类中找，有就使用
                - 找不到，就报错。
84. 方法重写
    - 什么是方法重写，子类父类里出现了一模一样的方法
        - 父类子类之间
        - 相同的方法名、参数列表、返回值类型
        - 可见性不能被缩小
        - 异常不能被扩大
    - 什么时候用
        - 当子类需要父类的功能，而子类又有自己特定的内容时，可以重写父类中的方法。
        - 这样，既沿袭了父类的功能，又定义了子类特有的内容
    - 注意
        - 父类的私有方法不能被重写，子类根本无法继承啊
        - 子类重写父类方法时候，权限不能更低，最好一致
        - 父类静态方法，子类必须也通过静态方法进行重写，（其实算不上重写，静态只能覆盖静态）
        - 子类重写父类方法时候，最好声明一模一样
85. [方法重载与方法重写的关系](https://github.com/hollischuang/toBeTopJavaer/blob/master/basics/java-basic/overloading-vs-overriding.md)
    - ![img](https://i.loli.net/2019/10/11/ehmHD29TB8C1wVo.png)
86. 继承中构造方法的关系
    - 构造方法不能被继承
    - 子类中所有的构造方法默认都会调用父类中无参数的构造方法
    - 因为子类会继承父类中的数据，可能还会使用父类的数据
    - 所以子类初始化之前，一定要先完成父类数据的初始化
    - 子类构造方法的第一条语句默认是super();
    - java.lang.Object类 最顶层的父类
    - 父类没有无参构造方法，子类怎么办？
        - 子类构造器中必须通过super(...)解决
        - super(...)或者this(...)必须是构造方法的第一句
87. this和super的区别
    - 调用成员变量
        - this.成员变量：调用本类的成员方法，也可以调用父类的成员变量
        - super.还曾元变量：调用父类的成员变量
    - 调用成员方法
        - this.成员方法：调用本类的成员方法，也可以调用父类的成员方法
        - super.成员方法：调用父类的成员方法
    - 调用构造方法
        - this(...)：调用本类的构造方法
        - super(...)：调用父类的构造方法
88. 什么叫多态
    - 同一类域的不同对象在调用同一方法的时候表现不同
    - 同一类域的含义：是指继承同意父类或实现同一接口的类的集合
    - 代码
        - 父类类型 变量名 = new 子类对象
        - 变量名.方法名();
        - 当多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译报错，如果有，执行的是子类重写后的方法。
    - 多态中的成员访问
        - 成员变量：编译看左边（父类），运行看左边（父类），所有的成员变量取决于编译时类型
        - 成员方法：编译看左边，运行看右边，所有成员方法取决于运行时的类型
        - 静态方法：编译看左边，运行看左边，所有静态方法取决于编译时的类型。
    - 类型转换
        - 向上转型：多态本身是子类类型向上转换的过程，这个过程是默认的。`Animal a1 = new Cat();`
        - 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。`if (a1 instanceof Cat) { Cat c = (Cat) a1; }`
        - 为什么要转型？当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译报错，就是说，不能调用子类拥有，而父类没有的方法。想要调用子类特有的方法，必须做向下转型。
89. 多态存在的三个必要条件
    - 要有继承
    - 要有方法重写
    - 父类引用指向子类对象
90. 多态有哪些好处和弊端
    - 提高了代码的维护性（继承来保证）
    - 提高了代码的扩展性（多态来保证），父类当作形式参数，接受任意子类对象
    - 弊端是不能直接使用子类的特有属性和行为
91. 什么是static
92. static关键字的特点
    - 随着类的加载而加载
    - 优先于对象存在
    - 被类的所有对象共享
    - 那么他就应该被定义为静态的
93. static的注意事项
    - 在静态方法中不能使用this关键字
    - 静态是随着类的加载而加载，this是睡着对象的创建而存在，静态比对象先存在
    - 静态方法只能访问静态成员变量和静态成员方法
94. 静态变量和成员变量的区别
    - 所属不同
        - 静态变量属于类，所以也称为类变量
        - 成员变量属于对象，所以也称为实例变量
    - 内存出现时间不同
        - 静态变量随着类的加载而加载，随着类的消失而消失
        - 成员变量随着对象的创建而存在，随着对象的消失而消失
    - 调用不同
        - 静态变量可以通过类名调用，也可以通过对象调用
        - 成员变量只能通过对象名调用
95. 什么叫代码块
    - 在Java中，使用花括号括起来的代码被称为代码块
96. 代码块分类
    - 局部代码块
    - 构造代码块
    - 静态代码块
    - 同步代码块
97. 常见代码块的应用
    - 局部代码块
        - 在方法中出现：限定变量生命周期，及早释放，提高内存利用率
    - 构造代码块（初始化块）
        - 在类中方法外出现，多个构造方法中相同的代码存放到一起，每次调用构造方法都执行，并且在构造方法之前执行
    - 静态代码块
        - 在类中方法外出现，并加上static修饰，用于给类进行初始化，在加载的时候就执行，并且只执行一次。一般用于加载驱动。
98. 何谓静态导入
    - 将类中的静态属性、静态方法导入本类，直接访问，简化编程
99. 什么是final
    - final关键字修饰类方法以及变量
100. final关键字修饰类、方法以及变量的特点
    - 修饰类，类不能被继承
    - 修饰方法，方法不能被重写
    - 修饰变量，变量就成了常量，只能被复制一次，一般与public STATIC相同
101. final关键字修饰局部变量
    - 基本类型，是值不能被改变
    - 引用类型，是地址值不能被改变，对象中的属性可以改变
102. final修饰成员变量的初始化时机
    - 显式初始化
    - 在对象构造完毕之前即可（构造器中）
103. 什么是abstract
    - 抽象类：不具体的类，不能实例化，用来继承用的
    - abstract修饰类、方法
    - 抽象类不能实例化
    - 抽象类中不一定有抽象方法，有抽象方法一定是抽象类
    - 抽象类的子类要么是抽象的，要么实现父类中的所有抽象方法
    - abstract不能修饰变量
    - abstract不能与static、final、private同用
    - 抽象类有构造器
104. 什么是interface
    - 接口：一种特殊的抽象类，用来定义规范，让子类实现
    - interface进行定义
    - 不能实例化
    - 子类要实现接口中所有抽象方法
    - 变量必须是常量 public static final
    - 成员方法都是抽象的 public abstract
    - 接口没有构造器
105. 类、接口继承关系
    - 类与类 extends 继承关系，只能单继承，可以多层继承
    - 类与接口 implements实现关系，可以单实线，也可以多实现，可以继承一个类，同时实现多个接口
    - 接口与接口：extends继承关系，可以单继承，也可以多继承。

106. 访问控制
    - ![img](https://i.loli.net/2019/10/11/2HCtedMJYZET431.png)
    - 常见的修饰符
    - ![img](https://i.loli.net/2019/10/11/DmO5MBd8bATGgk7.png)
107. 什么叫内部类
    - 内部类，就是在类里面定义的类
108. 成员内部类
    - 定义在类的里面，方法的外面
109. 静态内部类
    - 定义在类的里面，方法的外面，用static修饰，只能访问外围静态的资源
110. 局部内部类
    - 定义在方法的里面
    - 局部内部类访问的局部变量必须是final的，jdk8中可以省略final关键字
        - 局部内部类对象生命周期和局部变量不同，有可能局部方法结束以后（局部变量也销毁后），局部内部类对象还存在，为了防止这个情况的发生，局部内部类对象创建时会拷贝一份局部变量
        - 由于是在局部内部类对象创建时拷贝局部变量，如何保持局部变量和拷贝数据一致性，需要使用final限定，拷贝后不变，保持一致性。
111. 内部类的作用
    - 解决命名冲突，范围比包更小
    - 可以方便访问外围类成员
    - 变相实现多重继承
112. 什么叫自动装箱
    - 基本数据类型转换为对应的数值包装类类型
113. 什么叫自动拆箱
    - 数值包装类类型转换为基本数据类型
114. ==比较和equals()方法
    - Object类的equals()方法
        - 比较其他某个对象是否与此对象相等
        - 由于比较对象的引用没有意义，一般建议重写该方法
        - 如果没有重写Object类的equals方法，equals方法和==号比较引用类型无区别，重写后的equals方法比较的是对象中的属性
115. toString()方法
    - public String toString()：返回该对象的字符串表示
116. String、StringBuffer、StringBuilder区别
    - String是不可变字符串
    - StringBuffer：可变字符串，多线程安全
    - StringBuilder：可变字符串，多线程不安全，非多线程环境效率更高
117. java.lang.Object
118. clone()
    - [浅克隆（浅拷贝）、深克隆（深拷贝）](https://blog.csdn.net/lovezhaohaimig/article/details/80372233)
    - 实现Cloneable接口，重写Object中的clone()方法
    - 浅克隆仅仅复制要克隆的对象，而不赋值她所引用的对象
    - 深克隆要把克隆的对象及其所引用的对象都复制了一边
119. finalize()
    - finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。
120. final、finalize、finally区别
    - 垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才真正回收对象占用的内存
    - 但是Java如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是或finalize()可能永远不被执行，显然指望他做收尾工作是远远不够的
    - Java程序又垃圾回收器，所以一般情况下内存问题不用程序员操心，但是有一种JNI(Java Native Interface)调用non-Java程序，比如C/C++，finalize()的工作就是回收这个部分的内存。
    - [final、finalize、finally区别](https://www.cnblogs.com/ktao/p/8586966.html)
        - final
            - final关键字用来修饰类、方法和变量
            - final修饰的类不能被继承
            - final修饰的方法不能被重写
            - final修饰的变量不能被更改
        - finally
            - 是try...catch...语句中的，异常处理的一部分。
            - 起到的作用是经常用来用于释放资源。它控制的代码永远会执行，除非是前面碰到`System.exit()`之类的让JVM退出的情况。
        - finalize
            - 是Object类的一个方法，用于垃圾回收。
121. java.lang.
    - 常见方法
        - public int length () ：返回此字符串的长度。
        - public String concat (String str) ：将指定的字符串连接到该字符串的末尾。
        - public char charAt (int index) ：返回指定索引处的 char值，下标从0开始。
        - public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。
        - public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。
        - public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。
        - public boolean contains(CharSequence s)：判断源字符串中是否包含s字符串
        - public boolean startsWith(String prefix)：判断字符串是不是以某个字符串前缀开始
        - public boolean endsWith(String suffix)：判断字符串是不是以某个字符串后缀结尾
        - public char[] toCharArray () ：将此字符串转换为新的字符数组。
        - public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。
        - public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。
        - public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。
122. 正则表达式
    - 匹配正整数：”\\d+”
    - 匹配正小数：”\\d+\\.\\d+”  
    - 匹配负整数：”-\\d+”
    - 匹配负小数：”-\\d+\\.\\d+”
    - 匹配保留两位小数的正数：”\\d+\\.\\d{2}”
    - 匹配保留1-3位小数的正数：”\\d+\\.\\d{1,3}”
    - 匹配合法的邮箱：”[a-zA-Z_0-9]+@[a-zA-Z_0-9]+(\\.[a-zA-Z_0-9]+)+”
    - 获取IP地址(192.168.1.100)中的每段数字：”\\.”
123. java.util.Date
124. java.util.SimpleDateFormat
125. java.util.Calendar
126. System
    - public static long currentTimeMillis()：返回以毫秒为单位的当前时间，与1970年01月01日00:00点之间的毫秒差值。
127. 什么叫集合
    - 存储其他对象的对象
128. 集合与数组的区别
    - 数组长度是固定的，集合的长度是可变的
    - 数组中存储的是同一类型的元素，可以先存储基本数据类型值，集合存储的都是对象，而且对象的类型可以不一致。
    - 如果元素个数是固定的推荐用数组，不是固定的推荐用集合。
129. Java集合框架
    - JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。
    - 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map
    - ![img](https://i.loli.net/2019/10/11/INV7HgSUmiXk1e5.png)
    - List:有序、可重复
    - SortedSet：有序、补充都
    - Set：无序、不重复
130. 集合的操作
    - Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：
    - public boolean add(E e)：把给定的对象添加到当前集合中 。
    - public void clear()：清空集合中所有的元素。
    - public boolean remove(E e)：把给定的对象在当前集合中删除。
    - public boolean contains(E e)：判断当前集合中是否包含给定的对象。
    - public boolean isEmpty()：判断当前集合是否为空。
    - public int size(): 返回集合中元素的个数。
    - public Object[] toArray()：把集合中的元素，存储到数组中
131. 迭代器
    - Iterator接口的常用方法如下：
    - public E next()：返回迭代的下一个元素。
    - public boolean hasNext()：如果仍有元素可以迭代，则返回 true。
    - 迭代器是对集合进行遍历，而每一个集合内部的存储结构都是不同的，所以每一个集合的存取都是不一样的，那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式。
    - 好处：第一规定了整个集合体系的遍历方式都是hasNext()和next()方法。第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可。
    - 原理：在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。
132. 什么是List
133. List的特点
    - 它是一个元素存取有序的集合，即元素的存入顺序和取出顺序一致。
    - 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素。
    - 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。
134. List常用方法
    - 继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法
    - public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。
    - public E get(int index) :返回集合中指定位置的元素。
    - public E remove(int index) : 移除列表中指定位置的元素, 返回的是被移除的元素。
    - public E set(int index, E element) :用指定元素替换集合中指定位置的元素,返回值的更新前的元素。
135. ArrayList
    - ArrayList 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以 ArrayList 是最常用的集合。
    - ArrayList中放自定义类对象
    - 注意：
        - 1）ArrayList.remove(int)按照下标删除，不会自动装箱
        - 2）迭代器遍历的同时，添加元素，并发修改异常，通过ListIterator.add(...)解决
        - java.util.ConcurrentModificationException
        - 3）遍历集合删除元素，**使用Iterator.remove()操作**，不要直接使用List.remove()
        - 4）集合数组互转Arrays.asList()/ArrayList.toArray()
136. LinkedList
    - LinkedList 集合数据存储的结构是双向链表结构。方便元素添加、删除的集合。
    - public void addFirst(E e) :将指定元素插入此列表的开头。
    - public void addLast(E e) :将指定元素添加到此列表的结尾。
    - public E getFirst() :返回此列表的第一个元素。
    - public E getLast() :返回此列表的最后一个元素。
    - public E removeFirst() :移除并返回此列表的第一个元素。
    - public E removeLast() :移除并返回此列表的最后一个元素。
137. ArrayList、LinkedList、Vector的特点
    - ArrayList底层数据结构是数组，查找快，增删慢。线程不安全，效率高
    - LinkedList底层数据结构是（双向）链表，查询慢，增删快。线程安全，效率低
    - Vector相对ArrayList查询慢，线程安全，相对LinkedList增删慢，数组结构。
138. 什么是Set
139. Set的特点
    - 元素无序、不重复
140. HashSet
    - 我们使用Set集合都是需要去掉重复元素的，如果在存储的时候逐个equals()比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用equals()方法的次数。
    - 根据对象的Hash值来确定元素在集合中的存储位置，具有良好的存取和查找性能。保证元素唯一性的方式依赖于hashCode方法和equals方法。
    - HashSet集合存储数据的结构（哈希表）：数组+链表+红黑树（JDK1.8增加了红黑树部分）
    - ![img](https://i.loli.net/2019/10/11/F2YpP4ZWcCKI57l.png)
    - ![img](https://i.loli.net/2019/10/11/nQKkva4XswEZY8o.png)
141. HashTable
    - 哈希表（HashTable）又叫做散列表，是根据关键码值（即键值对）而直接访问的数据结构。也就是说，它通过把关键码映射到表中一个位置来访问记录，以加快查找速度。这个映射函数就叫做散列（哈希）函数，存放记录的数组叫做散列表。
142. 红黑树
    - 是二叉树的一种，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。
143. LinkedHashSet
    - 它是链表和哈希表组合的一个数据存储结构。元素的存入顺序和取出顺序一致。
144. 什么是TreeSet
    - 有序，不可重复。可以指定一个顺序，对象存入后会按照指定的顺序排列
145. TreeSet自然顺序
    - Comparable
    - TreeSet类的add()方法中会把存入的对象提升为Comparable类型
    - 调用对象的compareTo()方法和集合中的对象比较
    - 根据compareTo()方法返回的结果进行存储
146. TreeSet比较器顺序
    - Comparator
    - 创建TreeSet的时候可以指定一个Comparator
    - 如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序
    - add()方法内部会自动调用Comparator接口中compare()方法排序
    - 调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数
147. 以上两种方式的区别
    - TreeSet构造函数什么都不传, 默认按照类中Comparable的顺序(没有就报错ClassCastException)；TreeSet如果传入Comparator, 就优先按照Comparator
148. 什么是Map
149. Map的特点
    - 将键映射到值的对象
    - 一个映射不能包含重复的键
    - 每个键最多只能映射到一个值
150. Map和Collection的不同
    - Map是双列的，Collection是单列的
    - Map的键唯一，Collection的子体系Set是唯一的
    - Map的数据结构只针对键有效，跟值无关；Collection的数据结构针对元素有效
151. Map常用方法
    - public V put(K key, V value) : 把指定的键与指定的值添加到Map集合中。
    - public V remove(Object key) : 把指定的键所对应的键值对元素从Map集合中删除，返回被删除元素的值。
    - public V get(Object key) 根据指定的键，在Map集合中获取对应的值。
    - public Set<K> keySet() : 获取Map集合中所有的键，存储到Set集合中。
    - public Set<Map.Entry<K,V>> entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。
152. HashMap
    - 存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。
153. LinkedHashMap
    - HashMap下有个子类LinkedHashMap，存储数据采用哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。
154. HashMap和HashTable的区别
    - Hashtable是JDK1.0版本出现的,是线程安全的,效率低;HashMap是JDK1.2版本出现的,是线程不安全的,效率高
    - Hashtable不可以存储null键和null值;HashMap可以存储null键和null值
155. TreeMap
    - 可以根据键进行排序，排序规则的指定同TreeSet相同
156. java.util.Properties
    - 通过load()操作，从文件中加载键值对
157. java.util.Stack
158. java.util.Collections
    - public static <T> boolean addAll(Collection<T> c, T... elements) :往集合中添加一些元素。
    - public static void shuffle(List<?> list) :打乱集合顺序。
    - public static <T> void sort(List<T> list) :将集合中元素按默认规则排序。
    - public static <T> void sort(List<T> list，Comparator<? super T> ) :将集合中元素按指定规则排序。
159. Collention和Collections的区别
    - java.utils.Collections是集合工具类，用来对集合进行操作。
160. 增强for循环
    - foreach
161. 什么叫泛型
    - 参数化数据类型，将数据类型作为参数进行传递
162. 泛型的好处
    - 提高安全性，将运行期的ClassCastException转到编译器报错
    - 避免了类型强转的麻烦
    - 增加可读性
163. 如何使用泛型
    - 定义格式：修饰符 class 类名<代表泛型的变量> {  }
    - 使用泛型： 即什么时候确定泛型，在创建对象的时候确定泛型
    - `ArrayList<String> list = new ArrayList<String>();`
    - 泛型不支持子类型，=号左右两边泛型类型保持一致
    - JDK7以后，=号右边的泛型类型可以省略
164. 什么叫通配符
    - <?>通配符，表示泛型类型未知，可以传递任何数据类型
    - <? extends 数据类型>限定通配符，可以传递“数据类型”及其子类型
    - <? super 数据类型>限定通配符，可以传递“数据类型”及其父类型
165. 自定义泛型类
    - 在类定义中加入类型参数，一般用大写字母表示
    - 类中类型用大写字母来代替
166. 什么叫裸类型
    - 泛型类型没有使用类型参数，类型不安全
167. 类型擦除
    - 编译以后的字节码文件中，所有泛型信息将被删除
168. enum
    - 和class、interface同级，用来定义枚举类型，取值在指定范围内
    - 使用注意
        - 可以定义在包、类中，但是不能定义在方法中
        - 枚举类型不能被继承
        - 枚举类型默认继承java.ang.Enum
        - 枚举类型可以有属性、方法、构造器（不能用public）
        - 枚举类型的每个取值都是自己的一个实例对象
        - 枚举类型可以实现接口
        - 枚举类型中有静态方法values()获取所有取值
        - 枚举类型中可以有抽象方法，必须在每个取值中重写
        - java.util.EnumSet集合辅助使用enum类型：allOf()/range()/of()...
        - java.util.EnumMap集合辅助使用enum类型
169. 反射的概念
    - 镜像：类被加载到内存以后，通过类镜像来表，java.lang.Class
    - 反射：在运行时，通过类镜像进行类操作（获取类信息、构建类对象、调用方法等）
    - 使用java.lang.reflect包下的API（Field、Method、Constructor等）
170. 反射的使用场景
    - 当类的信息在编译时无法确定，运行时才能确定下来时，必须使用反射进行相关操作
171. 反射编程步骤
    - 获取类镜像：Class = java.lang.Class.forName(...)
    - 如需要，创建类实例对象：Class-->newInstance()
    - 调用反射相关API
        - java.lang.reflect.Field
        - java.lang.reflect.Constructor
        - java.lang.reflect.Method
172. 类加载器（了解）
    - 负责将.class文件加载到内存中，并为之生成对应的Class对象。
    - 类加载器的分类
        - Bootstrap ClassLoader 根类加载器
            - 也被称为引导类加载器，负责Java核心类的加载
            - 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中
        - Extension ClassLoader 扩展类加载器
            - 负责JRE的扩展目录中jar包的加载。
            - 在JDK中JRE的lib目录下ext目录
        - Sysetm ClassLoader 系统类加载器
            - 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径
173. 什么叫异常
174. 有哪些常见的异常类型
    - 数组下标越界ArrayIndexOutOfBoundsException
    - 空指针NullPointerException
    - ClassCastException异常
    - NumberFormatException异常
    - RuntimeException
    - IllegalArgumentException
    - AWTException
    - IOException
    - FileNotFoundException
    - EOFException
175. 异常如何处理
    - JVM的默认处理方式
    - 把异常的名称、原因、位置等信息输出在控制台，同时会结束程序。
    - 一旦有异常发生，其后来的代码不能继续执行。
    - 解决程序中异常的手动方式
    - 176.177
176. try...catch...finally

        ```java
        try{
        可能产生异常的代码
        }catch(异常类型1){
        异常处理程序1
        }catch(异常类型2){
        异常处理程序2
        }finally{
        不管是否发生异常，都要执行的代码
        }

        ```

177. throws
    - 抛出一个指定的异常对象
    - throw new 异常类名(参数);
    - Jvm→main()→a()→b()
178. java.lang.Exception 异常类
    1. getMessage() 返回该异常的详细信息字符串，即异常提示信息
    2. toString() 返回该异常的名称与详细信息字符串
    3. printStackTrace() 在控制台输出该异常的名称与详细信息字符串、异常出现的代码位置
179. 异常使用需要注意哪些
    - 捕获异常要先小后大（先子类后父类）
    - 可以用catch(Exception e){}匹配默认异常处理分支，放在最后
    - try...finally...没有catch是可以的
    - 尽量不要在try语句中使用return
    - finally中的代码总是会被执行（除非遇到System.exit()），经常用来释放资源
    - 程序带着某个返回条件进行finally，如finally中修改了返回条件，以finally为准
    - 子类重写方法抛出的异常是父类方法抛出异常的交集
180. 异常的分类 ◀ [173.]
    - ![img](https://i.loli.net/2019/10/11/dYx4r8XaBefRgUc.png)
    - Error：应用程序无法处理
    - 检查型异常：必须自己写代码进行处理
    - Exception的子类，但不是RuntimeException及其子类
    - try...catch...finally在本方法中进行处理
    - throws抛给调用者进行处理
    - 非检查型异常（运行时异常）：无需写代码进行处理
    - 要么是RuntimeException，要么是其子类
181. 自定义异常
    - 继承java.lang.Exception，通过名字区别不同的异常，不需要重写任何方法；属于检查型异常
182. throw与throws
    - throws出现在方法声明头，而throw出现在方法体
    - throws表示出现异常的一种可能性，并不一定会发生这些异常，throw则是抛出异常，执行throw则一定抛出了某种异常对象
    - 两者都是消极的处理异常的方式，只是抛出或者可能抛出异常，但是不会由方法去处理异常，真正的处理异常由方法的上层调用者处理。
183. final、finally、finalize ◀ [119.]
    - final 修饰属性、方法和类，分别表示属性值不可变，方法不可重写，类不可继承。
    - finally是异常处理语句结构的一部分，表示其中的代码总是执行。
    - finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。
184. assert
    - 断言，测试时使用，当满足判断条件，程序继续进行，否则报错退出。
    - 需要通过java -ea开启断言功能
185. GUI省略
    - 容器 JFrame、JPanel
    - 布局管理器 FlowLayout、GridLayout、CardLayout、BorderLayout
186. 什么叫进程
    - 进程，是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，是系统运行程序的基本单位，系统运行一个程序即是从一个进程中创建、运行到消亡的过程。
187. 什么叫线程
    - 线程是进程的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这样的程序被称为多线程程序。简而言之：一个程序运行的以后至少有一个进程，一个进程中可以包含多个线程。
188. 什么叫并发
    - 并发是指两个或者多个事件在同一个时间段内发生
189. 什么叫并行
    - 并行是指两个或多个事件在同一时刻发生，同时发生。
190. 线程的三要素
    - CPU
    - 代码
    - 数据
    - 多线程并发执行并不能提高程序的运行速度，但是可以提高程序的运行效率，可以同时完成多项工作，让CPU使用率更高。
    - 宏观上并行，微观上串行
    - JVM运行时是多线程的，智商启动了垃圾回收线程和主线程。
    - 每个线程都有自己的线程栈，县城方法中的局部变量每个线程都有自己的副本
191. Java中实现多线程的方法
    1. 继承java.lang.Tread，重写run()方法
    2. 实现java.lang.Runnable，重写run()方法
    3. 两种方式的比较
        继承Thread类（建议）  
            好处是可以直接使用Thread类中的方法，代码简单  
            坏处是如果已经有了父类，就不能用这种方法，毕竟Java只有单继承  
        实现Runnable接口  
            好处是即使自己定义的线程类有了父类也没有关系，因为有了父类也可以实现接口，而且接口也是可以多实现的。  
        坏处是不能直接使用Thread中的方法，需要先获取到线程对象，才能调用Thread的方法，代码复杂
    4. 注意：
        - 调用start()启动多线程
        - 多次启动一个线程是非法的
        - 多线程具有可论证的确定性，但是实际上具有不可确定性
192. 多线程共享变量
    - 继承Thread，用static修饰的变量，在多个线程之间共享
    - 实现Runnable，成员变量在多个线程之间共享
193. 线程方法
    - getName() 获取线程名称
    - sleep() 使得线程睡眠
    - currentThread() 获取当前线程对象
    - isAlive() 判断当前线程是否还活着
    - join() 当前线程挂起，等待指定线程执行结束后，当前线程再继续
    - setDaemon(boolean) 设置守护线程，其他线程都结束，守护线程随之结束
    - 守护线程的优先级比较低，用于为系统中的其它线程提供服务。例如垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动退出。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。
194. 什么是同步代码块
        - 语法

            ```java
                synchronized(同步锁){
                    需要同步操作的代码
            }
            ```

        - 同步锁：对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁
        - 锁对象可以为任意类类型
        - 多线程对象要使用同一把锁
        - 注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着。
195. 同步代码块的语法
        - ↑
196. 什么情况下需要同步
        - 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作，这时就需要同步。
        - 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码。
        - 注意
                - 使用synchronized关键字加上一个锁对象来定义一段代码, 就叫同步代码块。
                - 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的
                - 使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的
                - 非静态同步方法的锁对象是:this
                - 静态同步方法的锁对象是:字节码对象（类镜像Class对象）
197. 线程安全
        - 多线程并发操作同一数据时, 就有可能出现线程安全问题  
        - 同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作
        - 锁的粒度：太细，并发性降低；太粗，数据可能不安全
        - 一般将多线程操作的共享对象，作为锁对象
        - 对共享数据进行操作的，可能引起数据不一致的代码，放到同步代码块中
        - “临界区”:对共享资源进行操作的代码区域
198. 线程之间的通信
        - 什么时候需要通信
                - 多个线程并发执行时, 在默认情况下CPU是随机切换线程的
                - 如果我们希望他们有规律地执行, 就可以使用线程通信
        - 怎么通信
                - 如果希望线程等待, 就调用java.lang.Object.wait()
                - 如果希望唤醒等待的线程, 就调用java.lang.Object.notify();
                - 这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用（synchronized锁对象和调用wait()/notify()的对象必须相同）
                - 如果就执行一次，确保wait()在notify()之前
199. 线程状态转换
        - ![img](https://i.loli.net/2019/10/11/CBbreL8GlUQF5t1.png)
        - sleep方法和wait方法的区别?
                - 这两个方法来自不同的类分别是Thread和Object
                - sleep方法在同步方法或同步代码块中,不释放锁；wait方法在同步方法或者同步代码块中,释放锁
200. 什么叫死锁
        - 两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象
        - 多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁
        - 同步代码块尽量不要嵌套使用
        - 死锁的发生必须具备以下四个必要条件：
        - 互斥条件：指线程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个线程占用。如果此时还有其它线程请求资源，则请求者只能等待，直至占有资源的线程用毕释放
        - 请求和保持条件：指线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它线程占有，此时请求线程阻塞，但又对自己已获得的其它资源保持不放。
        - 不剥夺条件：指线程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
        - 环路等待条件：指在发生死锁时，必然存在一个线程资源的环形链，即线程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
        - 通过给共享资源编号，顺序使用共享资源，解决死锁
201. 线程优先级
        - yield()：当前线程让出CPU，让其它线程有机会运行
        - setPrioirity(int)：设置线程的优先级，java中线程有1~10个优先级，数值越大优先级别越高
202. 什么叫可重入锁
        - ReentrantLock类实现了Lock，它拥有与synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。它还提供了在激烈争情况下更佳的性能。
        - 同步  使用lock()和unlock()方法进行同步，unlock()操作放到finally中
        - 通信 使用ReentrantLock类的newCondition()方法可以获取Condition对象  需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法  不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了
203. 读写锁
        - ReentrantReadWriteLock
        - "读-读"不互斥，提高效率
        - "读-写"互斥
        - "写-写"互斥
204. 线程组
        - Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制
        - 默认情况下，所有的线程都属于主线程组
205. 线程池
        - 程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。从JDK5开始，Java内置支持线程池
        - JDK5新增了一个Executors工厂类来产生线程池
        - newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
        - newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
        - newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行
        - newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
        - 使用步骤
                - 创建线程池对象
                - 创建Runnable/Callable实例
                - 提交Runnable/Callable实例
                - 关闭线程池
206. 定时任务调度
        - java.util.Timer
        - java.util.concurrent.ScheduledExecutorService
        - 使用开源类库Quartz、JCronTab
        - Timer的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。如果说某个任务出现了异常，这个定时器上的所有任务都会终止。
        - ScheduledExecutor每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。
207. volatile
        - 修饰的变量是易失（不稳定）变量
        - 线程可以把成员变量保存在线程工作内存（缓存）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用线程工作内存中的变量值的拷贝，造成数据的不一致。
        - volatile修饰的成员变量在每次被线程访问时，都强迫从主内存中重读该成员变量的值。当成员变量发生变化时，强迫线程将变化值回写到主内存。
        - 当我们把代码写好之后，虚拟机不一定会按照我们写的代码的顺序来执行。虚拟机在进行代码编译优化的时候，对于那些改变顺序之后不会对最终变量的值造成影响的代码，是有可能将他们进行指令重排序的。
        - 如果一个变量被声明volatile的话，那么这个变量不会被进行指令重排序。
        - 原子操作：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。由于Java中的运算并非是原子操作，所以导致volatile声明的变量无法保证线程安全。
        - volatile对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。
        - volatile具有可见性、有序性，不具备原子性。
        - 何时使用volatile？java中多线程共享的数据，并且不是放到synchronized代码块中进行操作，一写多读
        - volatile不会让线程阻塞，响应速度比synchronized高
208. IO
209. FileInputStream、FileOutputStream
        - read()一次读取一个字节，返回值是int，不是byte，只用低8位
        - write(int)一次写出一个字节，虽然写的是int，但到文件中的是byte，会自动去除前24位
        - FileOutputStream如果文件不存在，新建空文件；如果文件已经存在，清空其内容；如果想向文件追加内容，将构造器第二个参数传true
        - FileInputStream.available()：返回可读字节数
        - read(byte[])：一次读多个字节
        - wrire(byte[])：一次写多个字节
        - write(byte[] b, int off, int len)写出有效的字节个数
        - Filter相关的流，是辅助流，需要依赖其它流，起到功能增强的作用
210. BufferedInputStream、BufferedOutputStream
        - BufferedInputStream会一次性从文件中读取8192个字节, 存在缓冲区中, 返回给程序一个；程序再次读取时, 就不用找文件了, 直接从缓冲区中获取，直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个字节
        - BufferedOutputStream也内置了一个缓冲区(数组).程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中，直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里
        - flush()方法：用来刷新缓冲区的,刷新后可以再次写出
        - close()方法：用来关闭流释放资源的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会在关闭流之前刷新缓冲区,关闭后不能再写出
211. DataInputStream、DataOutputStream
        - 可以直接对java中的基本数据类型进行读、写操作
212. PipedInputStream、PipedOutputStream
        - 可以在线程间进行数据的交换
213. SequenceInputStream
        - 可以把多个字节流整合成一个, 顺序读取或写入
214. ByteArrayInputStream、ByteArrayOutputStream
        - 在内存中创建数组，当作缓冲区，最后一次性从缓冲区中获取数据
215. InputStreamReader、OutputStreamWriter
        - 字符流是可以直接读写字符的IO流
        - 按照指定的字符编码进行读写操作
216. BufferedReader、BufferedWriter
        - BufferedReader的read()方法读取字符时会一次读取若干字符到缓冲区, 然后逐个返回给程序, 降低读取文件的次数, 提高效率
        - BufferedWriter的write()方法写出字符时会先写到缓冲区, 缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率
217. FileReader、FileWriter
        - FileReader类的read()方法可以按照字符大小读取(使用系统默认字符编码)
        - FileWriter类(使用系统默认字符编码)的write()方法可以自动把字符转为字节写出(使用系统默认字符编码)
218. File
        - public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了
        - public boolean mkdir():创建文件夹 如果存在这样的目录，就不创建了
        - public boolean mkdirs():创建文件夹,如果父目录不存在，会帮你创建出来
        - public boolean renameTo(File dest):把文件重命名为指定的文件路径
        - public boolean delete():删除文件或者目录，不走回收站，目录下不能有子目录或文件
        - public boolean isDirectory():判断是否是目录
        - public boolean isFile():判断是否是文件
        - public boolean exists():判断是否存在
        - public boolean canRead():判断是否可读
        - public boolean canWrite():判断是否可写
        - public boolean isHidden():判断是否隐藏
        - public String getAbsolutePath()：获取绝对路径
        - public String getPath():获取路径
        - public String getName():获取名称
        - public long length():获取长度。字节数
        - public long lastModified():获取最后一次的修改时间，毫秒值
        - public String[] list():获取指定目录下的所有文件或者文件夹的名称数组
        - public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组
219. RandomAccessFile
220. 对象持久化 ObjectInputStream、ObjectOutputStream
221. 网络编程概念
222. 基于TCP协议网络服务器端编程步骤
        - 1）创建服务器端Socket，并绑定在某一端口上
        - ServerSocket ss = new ServerSocket(port);
        - 2）接收客户请求，返回客户端Socket
        - Socket s = ss.accept();
        - 3）获取客户端的输入、输出流
        - s.getInputStream();
        - s.getOutputStream();
        - 4）封装输入、输出流
        - 5）执行读、写操作
        - 6）释放资源
        - close();
223. URL、URLConnection：获取远程站点的信息
224. 基于UDP协议网络服务器端编程步骤
        - 1）创建Socket，并指定服务器的IP和端口信息
        - Socket s = new Socket(serverAddress,serverPort);
        - 2）获取服务器端的输入、输出流
        - s.getInputStream();
        - s.getOutputStream();
        - 3）封装输入、输出流
        - 4）执行读、写操作
        - 5）释放资源
        - close();
225. 协议
226. IP
227. TCP
        - 传输控制协议，面向连接（三次握手）、可靠的数据传输；占用带宽，效率低；提供数据确认和重传的机制，保证数据一定能够到达数据接收端。
228. UDP
        -用户数据报协议，无连接、不可靠数据传输；占用带宽小，效率高；
不需要建立连接，可以直接向一个IP地址发送数据，至于是不是能够收到不能保证，发送过程中数据有可能丢失、IP地址可能不存在、IP地址代表的主机没有运行等原因都可能导致不能接收到数据。
229. HTTP
230. 接口
231. Lambda表达式
232. 函数描述符
233. 方法引用
234. stream

<style>
*  {
    font-family: Fira Code Regular, PingFang SC Regular!important;
    font-size: 20px!important;
}
</style>
