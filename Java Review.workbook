# Java&Linux复习

今天把Linux和Java这些日子的知识点回忆一下，以写代码为主吧，嗯。

## Linux

1. 1970年可以看作 Unix 诞生元年
2. Linux的意思是 Linux is not Unix 的意思
3. Linux的系统组成可以看成一个洋葱模型：内核→外壳→文件系统
4. Linux内核的作用就是管理硬件设备、内存、进程等
5. 外壳也就是shell，是个解释器，接受用户命令，交给内核去执行
6. $这个标志的出现代表普通用户
7. #这个标志的出现代表超级用户root
8. 使用su命令切换用户，什么都不填默认切换到超级用户
9. su后面如果跟一个-的话，就是切换到超级用户并且使用超级用户的用户配置
10. 超级用户切换普通用户也可以使用exit
11. 可以使用whoami查看当前用户是谁
12. 文件系统的功能是管理所用文件，是个倒立的树形结构
13. Linux中/是根目录
14. .表示当前目录，..表示上一级目录
15. 绝对路径就是以/开头的，否则是相对路径
16. ~这个表示家目录，一般是/home/zyj这样
17. 我们可以使用df -h查看分区
18. 常用目录了解一下？
    1. /bin bin是Binary的缩写，这个目录存放着最经常使用的命令。
    2. /boot 这个目录下存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。
    3. /dev 这个目录是Device设备的意思，存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。
    4. /home 用户的主目录，在Linux中，每个用户都有自己的一个目录，一般该目录是以用户的账号命名的。
    5. /lib 这个目录里存放的是系统最基本的动态链接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些动态链接共享库。
    6. /lost+found 这个目录一般是空的，当系统非法关机以后，这里就存放了一些文件
    7. /media Linux系统会自动识别一些设备，例如U盘、光驱等，当时别以后，Linux会把识别的设备挂载在这个目录下面
    8. /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以把光驱挂载在/mnt/上，然后进去这个目录就能看到光驱里的内容了。
    9. /opt 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库就可以放在这个文件夹下，默认是空的/
    10. /proc 这个目录是一个虚拟目录，他是系统内存的映射，我们可以通过这个目录来获取系统信息，这个目录的内容不是在硬盘上，而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，是别人无法ping你的机器`echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all`
    11. /root 该目录为系统管理员，也称作超级权限者的用户主目录
    12. /sbin s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。
    13. /selinux 这个目录是RedHeat/CentOS的特有的目录，Selinux是一个安全机制，类似于Windows防火墙这样的，但是这套机制比较复杂，这个目录就是存放selinux相关文件的。
    14. /srv 该目录存放一些服务启动后所需要提取的数据。
    15. /sys 这是Linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。
    16. /tmp 这个目录是用来存放一些临时文件的
    17. /usr 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program目录
    18. /usr/bin 系统用户使用的用用程序
    19. /usr/sbin 超级用户使用的比较高级的管理程序和系统守护程序
    20. /usr/src 内核源代码的默认放置目录。
    21. /var 这个目录中存放着在不断扩充的东西，我们习惯将那些经常被修改的目录放在这个目录下，包括各种日志文件。
    22. /run 实力个临时文件系统，存储系统启动以来的信息，当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让他指向run
19. 常用命令了解一下？
    1. 首先先看命令的语法：命令+选项+参数，用空格作为分隔符，一般不超过256字符、大小写敏感。
    2. 下面的命令按照字母顺序给出，需要详细了解的会写的全一点，否则就写个功能。
    3. cat
        1. cat命令用于连接文件并打印到标准输出设备上。
        2. 使用权限：所有使用者
        3. `cat [-AbeEnstTuv] [--help] [--version] fileName`
        4. -n 或 --number：由 1 开始对所有输出的行数编号。
        5. -b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。
        6. -s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。
        7. -v 或 --show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。
        8. -E 或 --show-ends : 在每行结束处显示 $。
        9. -T 或 --show-tabs: 将 TAB 字符显示为 ^I。
        10. -A, --show-all：等价于 -vET。
        11. -e：等价于"-vE"选项
        12. -t：等价于"-vT"选项；
    4. chmod
        1. Linux/Unix文件调用权限分为三级：文件拥有者、群组、其他。利用chmod可以藉以控制文件如何被他人调用。
        2. 使用权限：所有使用者
        3. `chmod [-cfvR] [--help] [--version] mode file...`
        4. u表示该文件的拥有者，g表示与该文件拥有者属于同一个群组的者，o表示其他以外的人，a表示这三者皆是
        5. +表示增加权限，-表示取消权限，=表示唯一设定权限
        6. r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行
        7. -c : 若该文件权限确实已经更改，才显示其更改动作
        8. -f : 若该文件权限无法被更改也不要显示错误讯息
        9. -v : 显示权限变更的详细资料
        10. -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)
        11. --help : 显示辅助说明
        12. --version : 显示版本
        13. chmod也可以使用数字来表示权限，`chmod abc file`。abc表示u、g、o的权限数字，rwx数字分别为4、2、1，取什么权限相加即可。例如rwx就是4+2+1=7，rw就是4+2=6之类。
        14. 若用`chmod 4755 filename`可以使该程序具有root的权限
    5. chown
        1. 利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。
        2. 使用权限：root
        3. `chown [-cfhvR] [--help] [--version] user[:group] file...`
    6. diff
        1. Linux diff命令用于比较文件的差异。diff以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。
        2. `diff [-abBcdefHilnNpPqrstTuvwy][-<行数>][-C <行数>][-D <巨集名称>][-I <字符或字符串>][-S <文件>][-W <宽度>][-x <文件或目录>][-X <文件>][--help][--left-column][--suppress-common-line][文件或目录1][文件或目录2]`
    7. file
        1. Linux file命令用于辨识文件类型。通过file指令，我们得以辨识该文件的类型。
        2. `file [-bcLvz][-f <名称文件>][-m <魔法数字文件>...][文件或目录...]`
        3. -b 　列出辨识结果时，不显示文件名称。
        4. -c 　详细显示指令执行过程，便于排错或分析程序执行的情形。
        5. -f<名称文件> 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。
        6. -L 　直接显示符号连接所指向的文件的类别。
        7. -m<魔法数字文件> 　指定魔法数字文件。
        8. -v 　显示版本信息。
        9. -z 　尝试去解读压缩文件的内容。
        10. [文件或目录...] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。
    8. find
        1. Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。
    9. mv
        1. Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。
        2. `mv [options] source dest`
        3. `mv [options] source... directory`
        4. -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;
        5. -f: 在mv操作要覆盖某已有的目标文件时不给任何指示;
    10. clear
        1. Linux clear命令用于清除屏幕。
    11. pwd
        1. Linux pwd命令用于显示工作目录。执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。
        2. `pwd [--help][--version]`
    12. cd
        1. Linux cd命令用于切换当前工作目录至 dirName(目录参数)。其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。另外，"~" 也表示为 home 目录 的意思，"." 则是表示目前所在的目录，".." 则表示目前目录位置的上一层目录。
        2. `cd [dirName]`
    13. ls
        1. Linux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。
        2. `ls [-alrtAFR] [name...]`
        3. -a 显示所有文件及目录 (ls内定将文件名或目录名称开头为"."的视为隐藏档，不会列出)
        4. -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出
        5. -r 将文件以相反次序显示(原定依英文字母次序)
        6. -t 将文件依建立时间之先后次序列出
        7. -A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)
        8. -F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"
        9. -R 若目录下有文件，则以下之文件亦皆依序列出
    14. touch
        1. Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。ls -l 可以显示档案的时间记录。
        2. `touch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]`
        3. a 改变档案的读取时间记录。
        4. m 改变档案的修改时间记录。
        5. c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。
        6. f 不使用，是为了与其他 unix 系统的相容性而保留。
        7. r 使用参考档的时间记录，与 --file 的效果一样。
        8. d 设定时间与日期，可以使用各种不同的格式。
        9. t 设定档案的时间记录，格式与 date 指令相同。
        10. --no-create 不会建立新档案。
        11. --help 列出指令格式。
        12. --version 列出版本讯息。
    15. mkdir
        1. Linux mkdir命令用于建立名称为 dirName 之子目录。
        2. `mkdir [-p] dirName`
        3. -p 确保目录名称存在，不存在的就建一个。
    16. cp
        1. Linux cp命令主要用于复制文件或目录。
        2. `cp [options] source dest`
        3. `cp [options] source... directory`
        4. -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。
        5. -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。
        6. -f：覆盖已经存在的目标文件而不给出提示。
        7. -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。
        8. -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。
        9. -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。
        10. -l：不复制文件，只是生成链接文件。
    17. rm
        1. Linux rm命令用于删除一个文件或者目录。
        2. `rm [options] name...`
        3. -i 删除前逐一询问确认。
        4. -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。
        5. -r 将目录及以下之档案亦逐一删除。
        6. 删除文件可以直接使用rm命令，若删除目录则必须配合选项"-r"
    18. man
    19. info
    20. telnet
        1. Linux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。
    21. exit
        1. Linux exit命令用于退出目前的shell。执行exit可使shell以指定的状态值退出。若不设置状态值参数，则shell以预设值退出。状态值0代表执行成功，其他值代表执行失败。exit也可用在script，离开正在执行的script，回到shell。
    22. ping
        1. Linux ping命令用于检测主机。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。
    23. ifconfig
        1. Linux ifconfig命令用于显示或设置网络设备.ifconfig可设置网络设备的状态，或是显示目前的设置。
    24. more
        1. Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。
    25. head
    26. tail
        1. tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。tail -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。
    27. history
    28. !
    29. !!
    30. alias
        1. Linux alias命令用于设置指令的别名。用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.cshrc中设定指令的别名。
    31. grep
        1. Linux grep 命令用于查找文件里符合条件的字符串。grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。
    32. ln
        1. Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。
        2. `ln [参数][源文件或目录][目标文件或目录]`
        3. Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。
        4. 软链接：
            1. 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
            2. 软链接可以 跨文件系统 ，硬链接不可以
            3. 软链接可以对一个不存在的文件名进行链接
            4. 软链接可以对目录进行链接
        5. 硬链接：
           1. 硬链接，以文件副本的形式存在。但不占用实际空间。
           2. 不允许给目录创建硬链接
           3. 硬链接只有在同一个文件系统中才能创建
    33. crontab
        1. Linux crontab是用来定期执行程序的命令。当安装完成操作系统之后，默认便会启动此任务调度命令。crond命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。而linux任务调度的工作主要分为以下两类：  
            1. 系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存
            2. 个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置
        2. `crontab [ -u user ] file`
        3. `crontab [ -u user ] { -l | -r | -e }`
        4. 时程表的格式如下：`f1 f2 f3 f4 f5 program`
            1. 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。
            2. 当 f1 为 \* 时表示每分钟都要执行 program，f2 为 \* 时表示每小时都要执行程序，其馀类推
            3. 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推
            4. 当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推
            5. 当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其馀类推
20. Linux元字符
    1. \* 代表0或多个字符
    2. ？ 代表单一字符
    3. \[\]给定字符列表中匹配一个字符
    4. ； 连接多个命令，顺序执行
    5. | 管道符，将前面命令的输出结果座位后面命令的输入内容
    6. \> 重定向输出方向，从屏幕变为文件，覆盖方式
    7. \>\> 重定向输出方向，从屏幕变为文件，追加方式
    8. \< 重定向输入方向，从键盘变为文件。
21. vi编辑器
    1. vi编辑器有三种模式：命令模式（command mode）、插入模式（Insert mode）、底行模式（last line mode）。
    2. k：上
    3. j：下
    4. h：左
    5. l：右
    6. i：光标所在位置插入
    7. a：光标所在位置后插入
    8. o：光标所在行的下一行插入
    9. O：光标所在行的上一行插入
    10. Esc：输入模式回到命令模式
    11. x：删除一个字符
    12. dd：删除一行
    13. r：替换一个字符
    14. cc：替换一行
    15. yy：拷贝一行
    16. p：粘贴
    17. :w：保存
    18. :w filename：另存为
    19. :wq：保存并退出vi
    20. :q!：退出vi不保存
    21. ~：大小写转换
    22. J：Join，上下两行合成一行
    23. u：undo，撤销刚刚执行过的操作
    24. :set nu：设置行号
    25. :set nonu：取消行号设置
    26. :21：定位到21行
    27. 21G：定位到21行
    28. G：定位到最尾行
    29. 0：定位到当前行头
    30. $：定位到当前行尾
    31. /：光标所在位置往下查找
    32. ?：光标所在位置往上查找
    33. n：查找下一处
    34. :r filepath：在光标所在位置的下一行，插入另外一个文件的内容
    35. :1,$s/旧串/新串/g：全文替换
    36. :%s/旧串/新串/g：全文替换
22. 初始化文件
    1. 环境变量：一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时目录位置、系统目录位置、第三方应用软件的位置等
    2. 自定义环境变量： 环境变量名=环境变量值
    3. 获取环境变量值： $环境变量名
    4. umask：权限掩码，影响新建目录、文件的默认权限
    5. 新建目录的默认权限：777-umask值
    6. 新建文件的默认权限：777-umask值后，去掉执行权限
23. 扩展
    1. 设置UID，s权限加在拥有者上，针对可执行程序，在程序执行过程中，临时将程序调用者的权限提升为文件拥有者的权限
    2. 设置GID，s权限加在同组人上，针对可执行程序，在程序执行过程中，临时将程序调用者的权限提升为文件所属组的权限
    3. 粘着位，t权限，只针对目录，对目录中的内容删除有限制。root、目录拥有者不受限；其他用户只能删除自己的文件，不能删除别人的文件。例如：服务器上提交作业的共享目录。

## Java

1. Java历史无需多言，了解即可
2. 什么是JDK
    1. JDK，即Java Development Kit。JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包含了JRE，所以我们安装了JDK，就不需要再安装JRE了。
    2. 这里说的java开发工具是指
        - 编译工具->javac
        - 打包工具->jar
        - 等等。。
    3. 所以**JDK=JRE+JAVA开发工具**
3. 什么是JRE
    - 那JRE的话，就是Java Runtime Environment，包括JVM（Java虚拟机）和Java需要的核心类库。如果想运行一个开发好的Java程序，就需要安装JRE。
    - 所以说**JRE=JVM+类库**
4. Java安装相关
    - 了解之后我们开始安装JDK，安装好之后还需要配置环境变量。还记得我们在Linux那个文件里配置的吗？用户家目录下的.bashrc文件。
    - 配置的主要是如下的东西：
        - JAVA_HOME->JDK安装路径
        - PATH->添加Java工具命令的路径
        - CLASSPATH->Java类的装载路径
5. JDK目录结构
    - ![image.png](https://i.loli.net/2019/10/09/kZqJcr36mlM8GOz.png)
    - bin: 开发工具
    - include: 头文件
    - db: 自带的小型数据库
    - lib: 类库
    - jre: java运行环境
    - src.zip: java源代码
6. 什么是Java
    - 它是一种开发语言，也是一种编程环境、应用环境、部署环境。
7. Java语言的特点
    - Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点，下面针对这些特点进行逐一介绍。
        1. 面向对象  
        Java 是一种面向对象的语言，它对对象中的类、对象、继承、封装、多态、接口、包等均有很好的支持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。使用 Java 语言开发程序，需要采用面向对象的思想设计程序和编写代码。  
        2. 平台无关性  
        平台无关性的具体表现在于，Java 是“一次编写，到处运行（Write Once，Run any Where）”的语言，因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。  
        Java 语言使用 Java 虚拟机机制屏蔽了具体平台的相关信息，使得 Java 语言编译的程序只需生成虚拟机上的目标代码，就可以在多种平台上不加修改地运行。  
        3. 简单性  
        Java 语言的语法与 C 语言和 C++ 语言很相近，使得很多程序员学起来很容易。对 Java 来说，它舍弃了很多 C++ 中难以理解的特性，如操作符的重载和多继承等，而且 Java 语言不使用指针，加入了垃圾回收机制，解决了程序员需要管理内存的问题，使编程变得更加简单。
        4. 解释执行  
        Java 程序在 Java 平台运行时会被编译成字节码文件，然后可以在有 Java 环境的操作系统上运行。在运行文件时，Java 的解释器对这些字节码进行解释执行，执行过程中需要加入的类在连接阶段被载入到运行环境中。  
        5. 多线程  
        Java 语言是多线程的，这也是 Java 语言的一大特性，它必须由 Thread 类和它的子类来创建。Java 支持多个线程同时执行，并提供多线程之间的同步机制。任何一个线程都有自己的 run() 方法，要执行的方法就写在 run() 方法体内。  
        6. 分布式  
        Java 语言支持 Internet 应用的开发，在 Java 的基本应用编程接口中就有一个网络应用编程接口，它提供了网络应用编程的类库，包括 URL、URLConnection、Socket 等。Java 的 RIM 机制也是开发分布式应用的重要手段。
        7. 健壮性  
        Java 的强类型机制、异常处理、垃圾回收机制等都是 Java 健壮性的重要保证。对指针的丢弃是 Java 的一大进步。另外，Java 的异常机制也是健壮性的一大体现。  
        8. 高性能  
        Java 的高性能主要是相对其他高级脚本语言来说的，随着 JIT（Just in Time）的发展，Java 的运行速度也越来越高。
        9. 安全性  
        Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防止恶意代码的攻击。除了 Java 语言具有许多的安全特性以外，Java 还对通过网络下载的类增加一个安全防范机制，分配不同的名字空间以防替代本地的同名类，并包含安全管理机制。  
        Java 语言的众多特性使其在众多的编程语言中占有较大的市场份额，Java 语言对对象的支持和强大的 API 使得编程工作变得更加容易和快捷，大大降低了程序的开发成本。Java 的“一次编写，到处执行”正是它吸引众多商家和编程人员的一大优势。
    - 简单版
        - 开源
        - 简单易用
          - 无指针，程序员不需要管理内存
        - 跨平台（JVM）
        - 支持多线程（提高并发效率）
        - 动态更新
        - 面向对象编程
        - 安全（代码安全校验器）
8. JVM
    - JVM我们看Java开发手册，这里我就不写了，太多了
9. GC
    - GC也是看Java开发手册，太多不写
10. Java代码安全
    - 代码安全主要就讲了个字节码校验器？看看之前总结的，我现在不想总结这个了。
    - 代码符合JVM规范
    - 不能破坏系统完整性
    - 不能有栈溢出
    - 参数类型要正确
    - 类型转换要正确
    - JIT:Just In Time，即时编译器，提高java代码的运行效率
11. 编程步骤
    - 编辑➡编译➡运行

    ```BASH
    vi src/Hello.java
    javac -d classes src/Hello.java
    java -cp classes cn.royians.review.Hello
    ```

12. 包
    - 解决命名冲突问题，分类管理。
13. jar命令
    - 打包：jar -cvf my.jar cn  
    - jar -xvf my.jar  
    - jar -tvf my.jar  
    - -cvf: 将.class文件打包
    - -xvf: 将.jar文件解包
    - -tvf: 查看.jar文件内容
    - `java -cp my.jar cn.royians.review.Hello`
14. API
    - 类的使用帮助文档
    - 包→类→属性、方法
15. Java注释有哪些？
    - 注释分三种
        - 单行注释
        - 多行注释
        - 文档注释
    - 单行注释主要用来对变量做简单描述  
    - 多行注释一般用来描述类、方法、算法  
    - 文档注释主要可以用来产生API文档。
    - 单行注释是可以嵌套的，但剩下那俩不行。  
    - 注释可以用来增加文章的可读性，只是在源文件中有效，编译成字节码以后，就全没了。  
    - 注释可以用来代码调试。
16. Java代码规范
    - 这个我在Java开发手册规范里看吧，这里不怎么说了
17. Java命名规则
    - 开头的必须是字母、下划线或者dollar符；而且命名是大小写敏感的，而且无长度限制（这一点的话呢，虽然说语言没有限制，但是这个长度是被机器限制了），而且肯定也不能用保留字/关键字。
18. Java中的标识符
    - ![Java中的关键字](https://i.loli.net/2019/10/09/E9drbgt4YqFHuCR.png)
19. Java数据类型
    1. 基本数据类型
        1. boolean，取值只能是true或false
        2. char，字符型，存放的是字符常量，底层用16位无符号整型数表示。这里需要我们记一下ASCII码，记常用的就行。比如0的编码是48，然后0123456789这样顺序排下去，最后那个9的编码是57.之后是：、；、<、=、>、？、@这种字符，然后从编号为65的A开始按字母顺序排列，一直到90的Z，然后又是一堆标点符号，到97的a记到122的z就行了。
        3. 整型族 位
            1. byte 8
            2. short 16
            3. int 32
            4. long 64
            5. 整型常量字面值默认是INT类型，可以直接赋给整型族变量（只要在范围内）
        4. 浮点型族
            1. float
            2. double
            3. 浮点常量字面值默认是double类型
            4. 建议使用BigDecimal或者Long（单位为分）来表示金额。
    2. 类类型（引用类型）
        1. String
            - [总结](https://www.jianshu.com/p/0dc5d48a1794)
            - [字符串的不可变性](https://www.cnblogs.com/qingergege/p/5701011.html)
            - [JDK 6和JDK 7中substring的原理及区别](https://www.cnblogs.com/dsitn/p/7151624.html)
            - [String对“+”的重载](https://www.jianshu.com/p/9bf533e40d30)
            - 字符串拼接的几种方式和区别
                - "+":有人把Java中使用`+`拼接字符串的功能理解为**运算符重载**。其实并不是，**Java是不支持运算符重载的**。这其实只是Java提供的一个**语法糖**
                - concat

                ```java
                String wechat = "ROYIANS";
                String introduce = "你好呀";
                String ROYIANS = wechat.concat(",").concat(introduce);
                ```

                - StringBuffer

                ```java
                StringBuffer wechat = new StringBuffer("ROYIANS");
                String introduce = "你好呀";
                StringBuffer ROYIANS = wechat.append(",").append(introduce);
                ```

                - StringBuilder

                ```java
                StringBuilder wechat = new StringBuilder("ROYIANS");
                String introduce = "你好呀";
                StringBuilder ROYIANS = wechat.append(",").append(introduce);
                ```

                - StringUtils.join

                ```java
                String wechat = "ROYIANS";
                String introduce = "你好呀";
                System.out.println(StringUtils.join(wechat, ",", introduce));
                String[] strs = {"str1", "str2"};
                System.out.println(StringUtils.join(Arrays.asList(strs),","));
                ```

            - [String.valueOf和Integer.toString的区别](https://github.com/ROYIANSchuang/toBeTopJavaer/blob/master/basics/java-basic/value-of-vs-to-string.md)
            - [switch对String的支持](https://github.com/ROYIANSchuang/toBeTopJavaer/blob/master/basics/java-basic/switch-string.md)
            - 字符串池
            - 常量池
                - 运行时常量池
                - Class常量池
            - intern
20. 什么是常量
    - 在程序执行过程中其值不可以发生改变
    - 常量是指在程序的整个运行过程中值保持不变的量。
    - 在这里要注意常量和常量值是不同的概念，常量值是常量的具体和直观的表现形式，常量是形式化的表现。
    - 通常在程序中既可以直接使用常量值，也可以使用常量。
21. Java中常量的分类
    1. 字面值常量
        1. 字符串常量 用双引号引起来的内容
        2. 整数常量 所有整数
        3. 小数常量 所有小数
        4. 字符常量 用单引号引起来的内容，里面只能放单个数字，单个字母或者单个符号
        5. 布尔常量 只有true和false
        6. 空常量 null
    2. 自定义常量
22. 什么是变量
    1. 在程序执行的过程中，在某个范围内其值可以改变的量
    2. 变量的定义的格式：数据类型 变量名 = 变量值
    3. 为什么要定义变量：用来存放同一类型的常量，并可以重复使用
23. 什么是类
    - 现实世界中，具有相同属性、相同行为的事物的抽象
24. 什么是对象
    - 类的具体化、实例化
25. 什么是面向对象
    - 将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。
    - 就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。
26. 面向对象编程的过程
    - 抽象类（class）→创建对象（new）→.访问属性（成员变量）、行为（成员方法）
27. 什么是局部变量
    - 定义在方法的里面
    - 必须先赋值后使用
    - 作用域是声明那一行到方法的右半花括号
28. 什么是实例变量
    - 定义在类的里面，方法的外面
    - 可以不用初始化直接使用，有默认值
    - 作用域：类的内部
29. 什么是作用域
    - 指标识符可以使用的有效范围
30. 什么是可见性
    - 指标识符可以被访问、引用的范围
    - 作用域内不一定可见，但可见一定在作用域内。
31. 任意进制到十进制的转换
32. 原码补码反码
    1. 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。
    2. 正数的补码与其原码相同；负数的补码是在其反码的末位加1。
33. 赋值操作符
    - int a = 10;
    - 数据类型要匹配
    - 左边只能是变量
    - 复合赋值运算符会将右值的类型隐式转换为左边的类型，可能会造成数据损失
34. [instanceof](https://www.cnblogs.com/ysocean/p/8486500.html)
    - 判断对象是否是某一类类型
    - 不能操作基本数据类型
    - java.lang.Object是所有类的父类
35. ==
    1. 如果是基本数据类型，==判断的是值
    2. 如果是对象类型，==判断的是对象的地址
36. 移位运算
    1. 左移运算符用“<<”表示，是将运算符左边的对象，向左移动运算符右边指定的位数，并且在低位补零；其实向左移n 位，就相当于乘上2的n次方。
    2. 右移运算符用符号“>>>”表示，逻辑右移，是将运算符左边的对象向右移动运算符右边指定的位数，并且在高位补0；其实右移n位，就相当于除上2的n次方。
    3. 带符号的右移运算符用符号“>>”表示，算数右移，是将运算符左边的运算对象，向右移动运算符右边指定的位数。如果是正数，在高位补零，如果是负数，则在高位补1
37. 位运算符
    1. & 与0相&，将某位清零
    2. | 与1相|，将某位置一
    3. ^ 与1相^，将某位反转
38. 逻辑运算符
    1. && 逻辑运算符，具有逻辑短路功能（连接的两个条件，如果第一个条件为假，后面的条件不进行运算）
    2. & 位运算符，但可以连接多个条件，但没有短路功能
39. [& 和 && 的区别](https://www.jianshu.com/p/7fe355536cc4)
40. 三目运算符 ？ ：
41. ++、--
    - ![img](https://i.bmp.ovh/imgs/2019/10/d396932c52a8faec.png)
42. Java类型转换
    1. 隐式类型转换，即自动类型转换，由系统自动完成的类型转换。从存储范围小的类型到存储范围大的类型。byte→short(char)→int→long→float→double。不仅如此，当把任何基本类型的值和字符串值进行连接运算时，基本类型的值将自动类型转换成字符串类型，虽然字符串类型不是基本类型，而是引用类型，因此，如果希望把基本类型的值转换为对应的字符串时，可以把基本类型的值和一个空字符串进行连接。
    2. 显式类型转换，即强制类型转换，就是缩小转换。
43. 顺序结构
44. 条件语句
    1. if
    2. if...else...
    3. if...else if...else...
45. 分支语句 switch
    - 表达式的数据类型，可以是byte、short、int、char、enum、String
46. 循环语句
    1. for
    2. while
    3. do...while...
    4. for、while区别
47. break、continue
    - break[label]：终止switch或者循环
    - continue[label]：结束本次循环，继续下一次的循环
    - Java中的标签是为循环设计的，是为了在多重循环中方便地使用break和continue跳到标签处
48. 死循环
    1. for(;;){...}
    2. while(true){...}
    3. do{...}while(true)
49. 什么是数组
    - Java中的数组是对象，有长度和数组成员
50. 如何声明数组
    - 数据类型[] 数组名
    - 数据类型 数组名[]
51. 如何创建数组
    - 数据类型[] 数组名 = new 数据类型[长度]
    - 数据类型[] 数组名 = new 数据类型[]{元素1, 元素2, ...}
    - 数据类型[] 数组名 = {元素1, 元素2, ...}
    - 可以存放基本数据类型，也可以存放类类型
    - 数组分配好堆内存后，会对成员进行默认初始化（数值类型为0，boolean类型为false，引用类型为null
52. 如何访问数组
    - 数组名[索引]
    - 数组名[索引] = 数值 为数组中的元素赋值
    - 变量 = 数组名[索引] 获取数组中的元素
    - 数组动态初始化： new分配内存，[]访问数组成员赋值，声明、赋值可以分开写
    - 数组的静态初始化：{}直接分配内存、赋值，声明、赋值不能分开写
53. 数组长度
    - 数组有长度，是固定的，Java赋予数组一个属性，可以获取到数组的长度，即 数组名.length
    - 数组下标访问时，可以使用变量
    - 数组访问时，编译器不会检查下标范围，需要自己负责
54. 数组遍历
    - fori
    - foreach
55. 数组常见异常
    1. ArrayIndexOutOfBoundsException
        - 数组下标越界
    2. NullPointerException
        - 空指针异常
56. 数组作为参数
    - 传递的参数是数组内存地址
57. 数组作为返回值
    - 返回的是数组的内存地址
58. 如何拷贝一个数组
    - System.arraycopy(...)

    ```java
    package cn.royians.review;

    import java.util.Arrays;

    public class ShuZuTest {
        public static void main(String[] args) {
            int[] intarr1 = {1,2,3,4,5,6};
            int[] intarr2 = new int[intarr1.length];
            System.arraycopy(intarr1,0,intarr2,0,intarr1.length);
            System.out.println(Arrays.toString(intarr1));
            System.out.println(Arrays.toString(intarr2));
        }
    }
    ```

59. 多维数组的练习
    - 其实没有多维数组，所谓的二维数组，就是一个一维数组，然后里面的元素是一维数组。
60. 什么叫可变参数
    - 底层用数组实现，一个参数列表中只能出现一个可变参数，并在所有参数的最后声明
    - someMethod(String... strings){...}
61. 面向对象编程思想
    - 强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现
    - 面向过程强调的是步骤，面向对象强调的是对象
    - 面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从中兴这变成了指挥者
    - 面向对象的三大特性：封装、继承、多态
62. 面向对象编程步骤
    1. 定义类

        ```java
        public class 类名 {
            //成员变量
            //成员方法
        }
        ```

    2. 创建对象

        ```java
        类名 对象名 = new 类名();
        ```

    3. 访问成员

        ```java
        对象名.成员变量;
        对象名.成员方法();
        ```

63. 什么是方法
    - 完成特定功能的代码块
64. 为甚要有方法
    - 提高代码复用性
65. 方法的格式

    ```java
    修饰符 返回值类型 方法名(参数类型 参数名1, 参数类型 参数名2...) {
        方法体语句;
        return 返回值;
    }
    ```

66. 方法格式的说明
    - 修饰符 public static protected private final
    - 返回值类型 就是功能结果的数据类型
    - 方法名 符合命名规则即可，方便我们的调用
    - 参数：
        - 实际参数：就是方法调用时的，实际参与运算的
        - 形式参数：就是方法定义上的，用于接收实际参数的
    - 参数类型：就是参数的数据类型
    - 参数名：就是变量名
    - 方法体语句：就是完成功能的代码
    - return：结束方法的，可以携带返回值也可以不携带
    - 返回值：就是功能的结果，由return带给调用者
67. 方法的注意事项
    - 方法不调用不执行
    - 方法与方法是平级关系，不能嵌套定义
    - 方法定义的时候参数之间用逗号隔开
    - 方法调用的时候不用再传递数据类型
    - 如果方法有明确的返回值，一定要有一个return带回一个值。
68. 什么叫封装
    - 封装是指隐藏对象的属性和实现细节，仅对外提供公共访问方式
69. 什么叫递归
    - 方法自己调用自己
    - 好处是不知道循环次数的时候可以用
    - 弊端是不能调用的次数太多，可能导致栈溢出
70. 封装有什么好处
    - 隐藏对象的属性和实现细节，仅对外提供公共访问方式
    - 提高了代码的复用性
    - 提高了安全性
71. 封装有哪些原则
    - 把属性隐藏，提供公共方法对其访问
    - 将不需要对外提供的内容都隐藏起来
72. private关键字 封装的操作
    - private关键字的特点：
        - 是一个权限修饰符
        - 可以修饰成员变量和成员方法
        - 被其修饰的成员只能在本类中被访问
        - private仅仅是封装一种体现形式，不能说封装就是私有
73. this
    - 代表所在类的当前对象的引用（地址值）
    - this.成员变量名
    - this.成员方法名
74. 方法重载
    - 在同一类中
    - 相同的方法名
    - 参数列表有所不同（参数类型、参数数量、参数顺序）
    - 不关心返回值类型
75. 什么叫初始化对象
76. 如何创建初始化对象
    - 在栈中分配空间，存放引用变量
    - 在堆中分配空间，存储对象；对象属性进行默认初始化
    - 引用变量指向堆地址
    - 使用成员变量值进行属性赋值
    - 调用构造器方法
77. 什么是构造器方法
    - 是一种特殊的方法，构建类对象时被调用
    - 和类同名
    - 没有返回值类型
    - 可以通过this(...)调用本类其他构造器，必须是构造器第一条语句
    - 如果没有提供构造器，系统会提供一个默认构造器（无参、空体）；如果提供了构造器，系统将不会提供默认构造器；建议自己在类中都添加一个无参构造器。
78. 什么是继承 extend
    - 多个类中存在相同的行为和属性时候。
    - 将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。
    - 其中，多个类可以称为子类
    - 单独的那一个类称为父类、超类或者基类
79. 继承有什么好处
    - 提高了代码的复用性
    - 提高了代码的维护性
    - 让类与类之间产生了关系，是多态的前提
80. 继承有什么弊端
    - 类的耦合性增强了
    - 开发的原则：高内聚、低耦合
    - 耦合：类和类的关系
    - 内聚：就是自己完成某件事情的能力
81. 什么时候用继承
    - 继承体现的是一种关系：“is-a”
82. 继承的特点
    - Java只支持单继承，不支持多继承
    - Java支持多层继承
83. [继承中成员变量与成员方法的关系](https://www.cnblogs.com/fuck1/p/5437777.html)
    - 继承中成员变量的关系
        - 子类的成员变量名称和父类中的成员变量名称不一样，这个太简单写那个名字就访问那个名字！
        - 子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?
            - 子类的方法访问变量的查找顺序：
                - 在子类方法的局部范围找，有就使用。
                - 在子类的成员范围找，有就使用。
                - 在父类的成员范围找，有就使用。
                - 找不到，就报错。
    - 继承中构造方法的关系
        - 子类的构造方法默认会去访问父类的无参构造方法，因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。
        - 子类通过super去明确调用带参构造，通过明确的调用指定的父类带参构造，为父类数据进行初始化。
        - 子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造，this();
    - 继承中成员方法的关系
        - 子类的成员方法和父类中的成员方法名称不一样，这个太简单
        - 子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?
            - 通过子类对象访问一个方法的查找顺序：
                - 在子类中找，有就使用
                - 在父类中找，有就使用
                - 找不到，就报错。
84. 方法重写
    - 什么是方法重写，子类父类里出现了一模一样的方法
        - 父类子类之间
        - 相同的方法名、参数列表、返回值类型
        - 可见性不能被缩小
        - 异常不能被扩大
    - 什么时候用
        - 当子类需要父类的功能，而子类又有自己特定的内容时，可以重写父类中的方法。
        - 这样，既沿袭了父类的功能，又定义了子类特有的内容
    - 注意
        - 父类的私有方法不能被重写，子类根本无法继承啊
        - 子类重写父类方法时候，权限不能更低，最好一致
        - 父类静态方法，子类必须也通过静态方法进行重写，（其实算不上重写，静态只能覆盖静态）
        - 子类重写父类方法时候，最好声明一模一样
85. [方法重载与方法重写的关系](https://github.com/hollischuang/toBeTopJavaer/blob/master/basics/java-basic/overloading-vs-overriding.md)
    - ![img](https://i.loli.net/2019/10/11/ehmHD29TB8C1wVo.png)
86. 继承中构造方法的关系
    - 构造方法不能被继承
    - 子类中所有的构造方法默认都会调用父类中无参数的构造方法
    - 因为子类会继承父类中的数据，可能还会使用父类的数据
    - 所以子类初始化之前，一定要先完成父类数据的初始化
    - 子类构造方法的第一条语句默认是super();
    - java.lang.Object类 最顶层的父类
    - 父类没有无参构造方法，子类怎么办？
        - 子类构造器中必须通过super(...)解决
        - super(...)或者this(...)必须是构造方法的第一句
87. this和super的区别
    - 调用成员变量
        - this.成员变量：调用本类的成员方法，也可以调用父类的成员变量
        - super.还曾元变量：调用父类的成员变量
    - 调用成员方法
        - this.成员方法：调用本类的成员方法，也可以调用父类的成员方法
        - super.成员方法：调用父类的成员方法
    - 调用构造方法
        - this(...)：调用本类的构造方法
        - super(...)：调用父类的构造方法
88. 什么叫多态
    - 同一类域的不同对象在调用同一方法的时候表现不同
    - 同一类域的含义：是指继承同意父类或实现同一接口的类的集合
    - 代码
        - 父类类型 变量名 = new 子类对象
        - 变量名.方法名();
        - 当多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译报错，如果有，执行的是子类重写后的方法。
    - 多态中的成员访问
        - 成员变量：编译看左边（父类），运行看左边（父类），所有的成员变量取决于编译时类型
        - 成员方法：编译看左边，运行看右边，所有成员方法取决于运行时的类型
        - 静态方法：编译看左边，运行看左边，所有静态方法取决于编译时的类型。
    - 类型转换
        - 向上转型：多态本身是子类类型向上转换的过程，这个过程是默认的。`Animal a1 = new Cat();`
        - 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。`if (a1 instanceof Cat) { Cat c = (Cat) a1; }`
        - 为什么要转型？当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译报错，就是说，不能调用子类拥有，而父类没有的方法。想要调用子类特有的方法，必须做向下转型。
89. 多态存在的三个必要条件
    - 要有继承
    - 要有方法重写
    - 父类引用指向子类对象
90. 多态有哪些好处和弊端
    - 提高了代码的维护性（继承来保证）
    - 提高了代码的扩展性（多态来保证），父类当作形式参数，接受任意子类对象
    - 弊端是不能直接使用子类的特有属性和行为
91. 什么是static
92. static关键字的特点
    - 随着类的加载而加载
    - 优先于对象存在
    - 被类的所有对象共享
    - 那么他就应该被定义为静态的
93. static的注意事项
94. 静态变量和成员变量的区别
95. 什么叫代码块
96. 代码块分类
97. 常见代码块的应用
98. 何谓静态导入
99. 什么是final
100. final关键字修饰类、方法以及变量的特点
101. final关键字修饰局部变量
102. final修饰成员变量的初始化时机
103. 什么是abstract
104. 什么是interface
105. 类、接口继承关系
106. 访问控制
107. 什么叫内部类
108. 成员内部类
109. 静态内部类
110. 局部内部类
111. 内部类的作用
112. 什么叫自动装箱
113. 什么叫自动拆箱
114. ==比较和equals()方法
115. toString()方法
116. String、StringBuffer、StringBuilder区别
117. java.lang.Object
118. clone()
119. finalize()
120. final、finalize、finally区别
121. java.lang.String
122. 正则表达式
123. java.util.Date
124. java.util.SimpleDateFormat
125. java.util.Calendar
126. System
127. 什么叫集合
128. 集合与数组的区别
129. Java集合框架
130. 集合的操作
131. 迭代器
132. 什么是List
133. List的特点
134. List常用方法
135. ArrayList
136. LinkedList
137. ArrayList、LinkedList、Vector的特点
138. 什么是Set
139. Set的特点
140. HashSet
141. HashTable
142. 红黑树
143. LinkedHashSet
144. 什么是TreeSet
145. TreeSet自然顺序
146. TreeSet比较器顺序
147. 以上两种方式的区别
148. 什么是Map
149. Map的特点
150. Map和Collection的不同
151. Map常用方法
152. HashMap
153. LinkedHashMap
154. HashMap和HashTable的区别
155. TreeMap
156. java.util.Properties
157. java.util.Stack
158. java.util.Collections
159. Collention和Collections的区别
160. 增强for循环
161. 什么叫泛型
162. 泛型的好处
163. 如何使用泛型
164. 什么叫通配符
165. 自定义泛型类
166. 什么叫裸类型
167. 类型擦除
168. enum
169. 反射的概念
170. 反射的使用场景
171. 反射编程步骤
172. 类加载器（了解）
173. 什么叫异常
174. 有哪些常见的异常类型
175. 异常如何处理
176. try...catch...finally
177. throws
178. java.lang.Exception
    1. getMessage()
    2. toString()
    3. printStackTrace()
179. 异常使用需要注意哪些
180. 异常的分类 ◀ [173.]
181. 自定义异常
182. throw与throws
183. final、finally、finalize ◀ [119.]
184. assert
185. GUI省略
186. 什么叫进程
187. 什么叫线程
188. 什么叫并发
189. 什么叫并行
190. 线程的三要素
    4. CPU
    5. 代码
    6. 数据
191. Java中实现多线程的方法
    7. 继承java.lang.Tread，重写run()方法
    8. 实现java.lang.Runnable，重写run()方法
    9. 两种方式的比较
    10. 注意：
        - 调用start()启动多线程
        - 多次启动一个线程是非法的
        - 多线程具有可论证的确定性，但是实际上具有不可确定性
192. 多线程共享变量
193. 线程方法
    - getName()
    - sleep()
    - currentThread()
    - isAlive()
    - join()
    - setDaemon()
194. 什么是同步代码块
195. 同步代码块的语法
196. 什么情况下需要同步
197. 线程安全
198. 线程之间的通信
    - 什么时候需要通信
    - 怎么通信
199. 线程状态转换
200. 什么叫死锁
201. 线程优先级
202. 什么叫可重入锁
203. 读写锁
204. 线程组
205. 线程池
206. 定时任务调度
207. volatile
208. IO
209. FileInputStream、FileOutputStream
210. BufferedInputStream、BufferedOutputStream
211. DataInputStream、DataOutputStream
212. PipedInputStream、PipedOutputStream
213. SequenceInputStream
214. ByteArrayInputStream、ByteArrayOutputStream
215. InputStreamReader、OutputStreamWriter
216. BufferedReader、BufferedWriter
217. FileReader、FileWriter
218. File
219. RandomAccessFile
220. 对象持久化 ObjectInputStream、ObjectOutputStream
221. 网络编程概念
222. 基于TCP协议网络服务器端编程步骤
223. URL、URLConnection：获取远程站点的信息
224. 基于UDP协议网络服务器端编程步骤
225. 协议
226. IP
227. TCP
228. UDP
229. HTTP


<style>
*  {
    font-family: Fira Code Regular, PingFang SC Regular!important;
    font-size: 20px!important;
}
</style>
